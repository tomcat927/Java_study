# 🚛 一分钟拿下一道面试题

# <font style="color:#DF2A3F;"></font><font style="color:rgba(255,165,0,1);">1.int和Integer有什么区别？</font>
+ **<font style="color:#DF2A3F;">基本类型/包装类型：</font>****Integer是int的****<font style="color:rgba(251,11,138,0.44);">包装类型</font>****，int则是java的一种****<font style="color:rgba(251,11,138,0.44);">基本数据类型</font>****。**
+ **<font style="color:#DF2A3F;">空值表示：</font>****Integer的默认值是null，int的默认值是0。**
+ **<font style="color:#DF2A3F;">类型转换：</font>****<font style="color:rgba(251,11,138,0.44);">int通过强制类型转</font>****换为其他类型，如 long，float 或double。Integer使用相应的****<font style="color:rgba(251,11,138,0.44);">方法进行</font>****<font style="color:rgba(255,140,0,1);"></font>****<font style="color:rgba(251,11,138,0.44);">类型转换</font>****，如intValue() 将其转换为 int 值。**
+ **<font style="color:#DF2A3F;">在集合中的使用：</font>****集合类（如 List、Set 等）只能存储对象，不能直接存储基本类型的值。因此，如果要在****<font style="color:rgba(251,11,138,0.44);">集合中存储整数</font>****，必须****<font style="color:rgba(251,11,138,0.44);">使用 Integer类型</font>****而不是int类型。**

# <font style="color:rgba(255,165,0,1);">2.== 与 equals 有什么区别？</font>
+ **<font style="color:#DF2A3F;">==：	</font>**
    - **用于****<font style="color:rgba(251,11,138,0.44);">基本类型</font>****比较时，****<font style="color:rgba(251,11,138,0.44);">比较值</font>****是否相等；**
    - **用于****<font style="color:rgba(251,11,138,0.44);">引用类型</font>****比较时，****<font style="color:rgba(251,11,138,0.44);">比较对象的内存地址</font>****是否相等。**
+ **<font style="color:#DF2A3F;">equals：</font>**
    - **默认是****<font style="color:rgba(251,11,138,0.44);">比较对象的内存地址</font>****，但大多数类都会****<font style="color:rgba(251,11,138,0.44);">重写equals方法</font>****来改变默认的行为，使其****<font style="color:rgba(251,11,138,0.44);">比较对象的内容</font>****而不是****<font style="color:rgba(251,11,138,0.44);">对象的内存地址</font>****。比如 String、Integer 重写了equals方法变成比较值是否相等。**

```java
@Test
public void compareDemo1() {
    int x = 10;
    int y = 10;
    //比较值相等，true
    System.out.println(x == y); // true

    String str1 = new String("baili");
    String str2 = new String("baili");
    //比较对象内存地址不相同，false
    System.out.println(str1 == str2); // false
    //比较字符相同，true
    System.out.println(str1.equals(str2)); // true
}



```

# <font style="color:rgba(255,165,0,1);">3.final 在 java 中有什么作用？</font>
**<font style="color:#DF2A3F;">定义常量：</font>****使用final关键字可以****<font style="color:rgba(251,11,138,0.44);">将变量声明为常量</font>****，一旦初始化后就不能再修改其值。**

**<font style="color:#DF2A3F;">禁止继承：</font>****当用final****<font style="color:rgba(251,11,138,0.44);">修饰类</font>****时，表示该类是****<font style="color:rgba(251,11,138,0.44);">最终的</font>****，不允许被其他类继承。**

**<font style="color:#DF2A3F;">禁止方法重写：</font>****当用final****<font style="color:rgba(251,11,138,0.44);">修饰方法</font>****时，表示该方法****<font style="color:rgba(251,11,138,0.44);">不可被子类重写</font>****。**

**<font style="color:#DF2A3F;">禁止参数重新赋值：</font>****当用final****<font style="color:rgba(251,11,138,0.44);">修饰方法的参数</font>****时，表示参数的值在方法体内****<font style="color:rgba(251,11,138,0.44);">不能被改变</font>****。**

**<font style="color:#DF2A3F;">线程安全性：</font>****当用final****<font style="color:rgba(251,11,138,0.44);">修饰对象时</font>****，表示该对象的****<font style="color:rgba(251,11,138,0.44);">引用不能被修改</font>****，但对象本身的****<font style="color:rgba(251,11,138,0.44);">状态是可变的</font>****。这可以确保在多线程环境下，该对象的引用不会被改变，从而避免潜在的并发问题。**

# <font style="color:rgba(255,165,0,1);">4.Java中常用于操作字符串的类有哪些？</font>
+ **<font style="color:#DF2A3F;">String：</font>****<font style="color:rgba(251,11,138,0.44);">不可变</font>****的字符串类，提供了多种****<font style="color:rgba(251,11,138,0.44);">字符串操作</font>****方法。如拼接、截取、****<font style="color:rgba(251,11,138,0.44);">查找</font>****等。**
+ **<font style="color:#DF2A3F;">StringBuilder：</font>****<font style="color:rgba(251,11,138,0.44);">可变</font>****的字符串类，****<font style="color:rgba(251,11,138,0.44);">非线程安全</font>****，适用于频繁修改字符串的情况。**
+ **<font style="color:#DF2A3F;">StringBuffer：</font>****<font style="color:rgba(251,11,138,0.44);">可变</font>****的字符串类，****<font style="color:rgba(251,11,138,0.44);">线程安全</font>****，适用于多线程环境。**
+ **<font style="color:#DF2A3F;">StringUtils：</font>****Apache Commons Lang 库中的一个****<font style="color:rgba(251,11,138,0.44);">工具类</font>****，提供了各种字符串操作方法。例如****<font style="color:rgba(251,11,138,0.44);">判断是否为空</font>****、去除空格、****<font style="color:rgba(251,11,138,0.44);">大小写转换</font>****等。**

# <font style="color:rgba(255,165,0,1);">5.String类的常用方法有哪些？</font>
+ **<font style="color:#DF2A3F;">equals()：</font>****比较字符串是否****<font style="color:rgba(251,11,138,0.44);">相等</font>****。**
+ **<font style="color:#DF2A3F;">indexOf()：</font>****返回第一个匹配子串的****<font style="color:rgba(251,11,138,0.44);">起始索引</font>****。**
+ **<font style="color:#DF2A3F;">substring()：</font>****返回从****<font style="color:rgba(251,11,138,0.44);">起始位置（包含）</font>****到****<font style="color:rgba(251,11,138,0.44);">结束位置（不包含）</font>****的子字符串。**
+ **<font style="color:#DF2A3F;">startsWith()：</font>****<font style="color:rgba(251,11,138,0.44);">检查</font>****字符串是否以****<font style="color:rgba(251,11,138,0.44);">指定的前缀开头</font>****。**
+ **<font style="color:#DF2A3F;">replaceAll()：</font>****使用给定的****<font style="color:rgba(251,11,138,0.44);">替换字符串</font>****替换所有匹配给定正则表达式的子字符串。**
+ **<font style="color:#DF2A3F;">trim()：</font>****去除字符串****<font style="color:rgba(251,11,138,0.44);">首尾</font>****的空白字符。**
+ **<font style="color:#DF2A3F;">split()：</font>****使用给定的正则表达式****<font style="color:rgba(251,11,138,0.44);">拆分字符串</font>****为字符串数组。**

# <font style="color:rgba(255,165,0,1);">6.String为什么要设计为不可变类？</font>
+ **<font style="color:#DF2A3F;">常量池的需要：</font>****字符串常量池可以****<font style="color:rgba(251,11,138,0.44);">共享</font>****相同的字符串对象，****<font style="color:rgba(251,11,138,0.44);">节省</font>****内存空间并****<font style="color:rgba(251,11,138,0.44);">提高</font>****性能**
+ **<font style="color:#DF2A3F;">hashCode 缓存的需要：</font>****字符串的哈希码被缓存，****<font style="color:rgba(251,11,138,0.44);">提高</font>****了散列集合的性能（如哈希表）**
+ **<font style="color:#DF2A3F;">线程安全性：</font>****<font style="color:rgb(38, 38, 38);">不可变类天然具备</font>****<font style="color:rgba(251,11,138,0.44);">线程安全</font>****<font style="color:rgb(38, 38, 38);">的特性，无需额外同步措施</font>**
+ **<font style="color:#DF2A3F;">安全性和可靠性：</font>****<font style="color:rgb(38, 38, 38);">不可变性确保</font>****<font style="color:rgba(251,11,138,0.44);">实例状态不会被修改</font>****<font style="color:rgb(38, 38, 38);">，适用于处理敏感信息等安全场景</font>**
+ **<font style="color:#DF2A3F;">共享和重用：</font>****<font style="color:rgb(38, 38, 38);">不可变类的实例可以</font>****<font style="color:rgba(251,11,138,0.44);">自由共享和重用</font>****<font style="color:rgb(38, 38, 38);">，提升性能效率</font>**

# <font style="color:rgba(255,165,0,1);">7.String、StringBuilder、StringBuffer 的区别？</font>
+ **<font style="color:#DF2A3F;">String：</font>****String类是****<font style="color:rgba(251,11,138,0.44);">不可变</font>****的，每次操作都会创建新的对象；它是****<font style="color:rgba(251,11,138,0.44);">线程安全</font>****的，可以在多线程环境下使用。**
+ **<font style="color:#DF2A3F;">StringBuilder：</font>****StringBuilder类是****<font style="color:rgba(251,11,138,0.44);">可变</font>****的，StringBuilder比String更高效。但是它是****<font style="color:rgba(251,11,138,0.44);">非线程安全</font>****的，不能保证线程安全性。**
+ **<font style="color:#DF2A3F;">StringBuffer：</font>****StringBuffer类是****<font style="color:rgba(251,11,138,0.44);">可变</font>****的，与StringBuilder不同的是，StringBuffer是****<font style="color:rgba(251,11,138,0.44);">线程安全</font>****的，可以在多线程环境下使用。****<font style="color:rgba(251,11,138,0.44);">需要注意</font>****，它通过使用****<font style="color:rgba(251,11,138,0.44);">同步方法</font>****来确保线程安全性，因此****<font style="color:rgb(38, 38, 38);">会带来</font>****<font style="color:rgba(251,11,138,0.44);">额外的性能开销</font>****<font style="color:rgb(38, 38, 38);">。</font>**

# <font style="color:rgba(255,165,0,1);">8.接口和抽象类有什么区别？</font>
+ **<font style="color:#DF2A3F;">定义方式：</font>****<font style="color:rgba(251,11,138,0.44);">接口</font>****使用关键字 ****<font style="color:rgba(251,11,138,0.44);">interface</font>**** 来定义； ****<font style="color:rgba(251,11,138,0.44);">抽象类</font>****使用关键字 ****<font style="color:rgba(251,11,138,0.44);">abstract</font>**** 来定义。**
+ **<font style="color:#DF2A3F;">实现方式：</font>****<font style="color:rgba(251,11,138,0.44);">一个类</font>****可以实现****<font style="color:rgba(251,11,138,0.44);">多个接口</font>****，但只能****<font style="color:rgba(251,11,138,0.44);">继承一个</font>****抽象类。**
+ **<font style="color:#DF2A3F;">内容：</font>****接口****<font style="color:rgba(251,11,138,0.44);">只有方法</font>****声明，****<font style="color:rgba(251,11,138,0.44);">没有实现体</font>****；抽象类可以****<font style="color:rgba(251,11,138,0.44);">有方法</font>****的声明和****<font style="color:rgba(251,11,138,0.44);">实现体</font>****，还可包含属性和构造方法等。**
+ **<font style="color:#DF2A3F;">实例化：</font>****接口不能被实例化；抽象类可以被继承并实例化。**
+ **<font style="color:#DF2A3F;">多继承：</font>****接口支持****<font style="color:rgba(251,11,138,0.44);">多继承</font>****；抽象类只能****<font style="color:rgba(251,11,138,0.44);">单继承</font>****。**
+ **<font style="color:#DF2A3F;">设计目的：</font>****接口定义****<font style="color:rgba(251,11,138,0.44);">约束和契约</font>****，强调****<font style="color:rgba(251,11,138,0.44);">行为一致性</font>****；抽象类提供通用基类，强调对子类的****<font style="color:rgba(251,11,138,0.44);">抽象和封装</font>****。**

# <font style="color:rgba(255,165,0,1);">9.ArrayList和LinkedList有什么区别？</font>
|  | **ArrayList** | **LinkedList** |
| --- | --- | --- |
| **<font style="color:#DF2A3F;">底层数据结构</font>** | **使用****<font style="color:rgba(251,11,138,0.44);">数组实现</font>** | **使用****<font style="color:rgba(251,11,138,0.44);">链表实现</font>** |
| **<font style="color:#DF2A3F;">插入和删除操作</font>** | **需要****<font style="color:rgba(251,11,138,0.44);">移动其他元素</font>****，时间复杂度为****<font style="color:rgba(251,11,138,0.44);">O(n)</font>** | **只需要****<font style="color:rgba(251,11,138,0.44);">修改指针</font>****的指向，时间复杂度为****<font style="color:rgba(251,11,138,0.44);">O(1)</font>** |
| **<font style="color:#DF2A3F;">随机访问</font>** | **根据****<font style="color:rgba(251,11,138,0.44);">索引</font>****直接****<font style="color:rgba(251,11,138,0.44);">访问</font>****元素，时间复杂度为****<font style="color:rgba(251,11,138,0.44);">O(1)</font>** | **需要****<font style="color:rgba(251,11,138,0.44);">遍历链表</font>****找到目标位置进行访问，时间复杂度为****<font style="color:rgba(251,11,138,0.44);">O(n)</font>** |
| **<font style="color:#DF2A3F;">适用场景</font>** | **频繁访问和随机访问，插入和删除较少的场景** | **频繁插入和删除，随机访问需求较少的场景** |


# <font style="color:rgba(255,165,0,1);">10.HashMap的底层数据结构</font>
**<font style="color:#DF2A3F;">JDK<=1.7：</font>****数组+链表；**

**<font style="color:#DF2A3F;">JDK>=1.8：</font>****数组+链表+红黑树；**

**<font style="color:#DF2A3F;">数组：</font>****时间复杂度是****<font style="color:rgba(251,11,138,0.44);">O(1)；</font>**

**<font style="color:#DF2A3F;">链表：</font>****时间复杂度是****<font style="color:rgba(251,11,138,0.44);">O(N)；</font>**

**<font style="color:#DF2A3F;">红黑树：</font>****时间复杂度是****<font style="color:rgba(251,11,138,0.44);">O(logn)；</font>**

**Hash值产生碰撞后，****<font style="color:rgba(251,11,138,0.44);">链表长度>8</font>****时会从****<font style="color:rgba(251,11,138,0.44);">链表转换为红黑树</font>****，而当红黑树的****<font style="color:rgba(251,11,138,0.44);">节点<6</font>****时，会从****<font style="color:rgba(251,11,138,0.44);">红黑树转换为链表</font>****。**

# <font style="color:rgba(255,165,0,1);">11.HashSet 的底层数据结构？</font>
+ **基于HashMap实现。**

```powershell
public HashSet() {
    map = new HashMap<>();
}
```

+ **值存放于HashMap的key上。**

```powershell
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

+ **HashMap的value统一为PRESENT。**

```powershell
private static final Object PRESENT = new Object();
```

# <font style="color:rgba(255,165,0,1);">12.HashMap和HashTable有什么区别？</font>
+ **<font style="color:#DF2A3F;">线程安全性：</font>****HashTable 是****<font style="color:rgba(251,11,138,0.44);">线程安全</font>****的，而 HashMap 不是。**
+ **<font style="color:#DF2A3F;">Null 值：</font>****HashMap ****<font style="color:rgba(251,11,138,0.44);">允许</font>****键和值都为 null，而 HashTable ****<font style="color:rgba(251,11,138,0.44);">不允许</font>****键或值为 null。**
+ **<font style="color:#DF2A3F;">继承关系：</font>****HashMap 继承自****<font style="color:rgba(251,11,138,0.44);"> AbstractMap 类</font>****，而 HashTable 继承自 ****<font style="color:rgba(251,11,138,0.44);">Dictionary 类</font>****<font style="color:#000000;">，已过时</font>****。**
+ **<font style="color:#DF2A3F;">性能：</font>****在****<font style="color:rgba(251,11,138,0.44);">单线程环境</font>****下，由于 HashMap 不需要进行额外的同步措施，通常比 HashTable 性能高。而在****<font style="color:rgba(251,11,138,0.44);">多线程环境</font>****下，HashTable保证了线程安全性，但因为同步操作引入了开销，所以性能相对较差。**

# <font style="color:rgba(255,165,0,1);">13.HashMap 与LinkedHashMap 的区别</font>
+ **<font style="color:#DF2A3F;">继承关系：</font>****LinkedHashMap 是 HashMap 的子类，继承了 HashMap 的基本功能，并在此基础上增加了维护插入顺序的功能。**
+ **<font style="color:#DF2A3F;">元素顺序：</font>****HashMap 不保证元素的顺序，而 LinkedHashMap 使用双向链表来维护元素的插入顺序**
+ **<font style="color:#DF2A3F;">底层数据结构：</font>****HashMap 使用数组和链表（或红黑树）来实现，而 LinkedHashMap 在 HashMap 的基础上，额外维护了一个双向链表。**

# <font style="color:rgba(255,165,0,1);">14.并发和并行的区别</font>
+ **<font style="color:#DF2A3F;">并发：</font>****<font style="color:rgba(251,11,138,0.44);">一个处理器</font>****同时处理多个任务，CPU通过时间片切换轮流执行不同的任务。 **
+ **<font style="color:#DF2A3F;">并行：</font>****<font style="color:rgba(251,11,138,0.44);">多个处理器</font>****或者是多核的处理器同时处理多个不同的任务，两个线程互****<font style="color:rgba(251,11,138,0.44);">不抢占CPU资源</font>****，可以同时进行。**

# <font style="color:rgba(255,165,0,1);">15.创建线程有哪几种方式</font>
+ **继承****<font style="color:rgba(251,11,138,0.44);">Thread类</font>****，重写该类的run()方法**
+ **实现****<font style="color:rgba(251,11,138,0.44);">Runnable接口</font>****，重写该接口的run()方法**
+ **实现****<font style="color:rgba(251,11,138,0.44);">Callable接口</font>****通过FutureTask包装器来创建线程**

# <font style="color:rgba(255,165,0,1);">16.线程的run()和start()有什么区别</font>
+ **start()方法用于****<font style="color:rgba(251,11,138,0.44);">启动一个新线程</font>****，并****<font style="color:rgba(251,11,138,0.44);">异步</font>****执行线程的任务**
+ **run()方法是线程的任务处理入口，会在当前线程中****<font style="color:rgba(251,11,138,0.44);">同步执行</font>******
+ **start()方法****<font style="color:rgba(251,11,138,0.44);">只能调用一次</font>****，而run()方法可以被多次调用**
+ **调用start()方法****<font style="color:rgba(251,11,138,0.44);">不会阻塞</font>****主线程，而调用run()方法****<font style="color:rgba(251,11,138,0.44);">会阻塞</font>****当前线程的执行**

# <font style="color:rgba(255,165,0,1);">17.Java线程有哪些状态</font>
+ **<font style="color:#DF2A3F;">新建（New）：</font>****线程被创建，但还没有调用start()方法**
+ **<font style="color:#DF2A3F;">运行（Runnable）</font>****：就绪或者运行中**
+ **<font style="color:#DF2A3F;">阻塞（Blocked）：</font>****表示线程阻塞，等待获取锁**
+ **<font style="color:#DF2A3F;">等待（Waiting）：</font>****<font style="color:#000000;">表示线程调用了wait方法</font>****，需要等待其他线程做出一些特定动作（通知或中断）**
+ **<font style="color:#DF2A3F;">超时等待（Timed waiting）：</font>****该状态不同于****<font style="color:#000000;">Waiting</font>****，它是可以在指定的时间自行返回**
+ **<font style="color:#DF2A3F;">死亡（Terminated）：</font>****表示当前线程已经执行完毕**

# <font style="color:rgba(255,165,0,1);">18.sleep()与 wait()的区别</font>
+ **sleep()是****<font style="color:rgba(251,11,138,0.44);">Thread类</font>****方法，而wait()是****<font style="color:rgba(251,11,138,0.44);">Object类</font>****方法**
+ **sleep()用于****<font style="color:rgba(251,11,138,0.44);">暂停</font>****当前正在执行的****<font style="color:rgba(251,11,138,0.44);">线程</font>****，****<font style="color:rgba(251,11,138,0.44);">不会释放</font>****对象锁**
+ **wait()用于使线程进入****<font style="color:rgba(251,11,138,0.44);">等待状态</font>****，****<font style="color:rgba(251,11,138,0.44);">会释放</font>****对象锁，并且需要在****<font style="color:rgba(251,11,138,0.44);">同步代码块</font>****或同步方法中使用。只能通过****<font style="color:rgba(251,11,138,0.44);">其他线程</font>****的notify()或notifyAll()来唤醒**

# <font style="color:rgba(255,165,0,1);">19.唤醒线程的方法有哪些</font>
+ **<font style="color:#DF2A3F;">notify()：</font>****该方法****<font style="color:rgba(251,11,138,0.44);">随机唤醒</font>****在对象上等待的****<font style="color:rgba(251,11,138,0.44);">单个线程</font>**
+ **<font style="color:#DF2A3F;">notifyAll()：</font>****该方法唤醒在对象上等待的****<font style="color:rgba(251,11,138,0.44);">所有线程</font>**
+ **<font style="color:#DF2A3F;">Lock 接口与 Condition 接口：</font>****使用 Lock 接口获取锁，并通过 Condition 接口的 ****<font style="color:rgba(251,11,138,0.44);">signal() </font>****或 ****<font style="color:rgba(251,11,138,0.44);">signalAll() </font>****来唤醒相应的线程**

# <font style="color:rgba(255,165,0,1);">20.创建线程池的常用方式</font>
+ **使用 ****<font style="color:#DF2A3F;">Executors 工厂类</font>****的****<font style="color:rgba(251,11,138,0.44);">静态方法</font>****，例如 ****<font style="color:#2F4BDA;">newFixedThreadPool()</font>****：固定线程数的线程池**

**    ****<font style="color:#2F4BDA;">newCachedThreadPool()</font>****：线程数动态变化的线程池**

**    ****<font style="color:#2F4BDA;">newSingleThreadExecutor()</font>****：单线程线程池**

+ **使用 ****<font style="color:#DF2A3F;">ThreadPoolExecutor 类</font>****的****<font style="color:rgba(251,11,138,0.44);">构造函数</font>****，手动设置核心线程数、最大线程数、线程空闲时间和任务队列等参数。**
+ **使用 ****<font style="color:#DF2A3F;">ForkJoinPool 类</font>****来执行 ****<font style="color:rgba(251,11,138,0.44);">Fork-Join</font>**** 任务的线程池。**

# <font style="color:rgba(255,165,0,1);">21.线程池的执行流程</font>
**线程池是一种管理和复用线程的机制，可以提高多线程程序的性能和资源利用率。下面是线程池的基本执行流程：**

![1694173086579-b6ea6b6c-fcea-4b46-8c21-bc8c2ecb9a8f.png](./img/NRYZr_RWH4KAbUI_/1694173086579-b6ea6b6c-fcea-4b46-8c21-bc8c2ecb9a8f-175095.png)<font style="color:rgb(51, 54, 57);"></font>

# <font style="color:rgba(255,165,0,1);">22.如何设置线程池的线程数</font>
+ **对于****<font style="color:rgba(251,11,138,0.44);">CPU密集型任务</font>****，由于这类任务主要消耗CPU资源而不涉及IO操作，因此****<font style="color:rgba(251,11,138,0.44);">线程数的设置</font>****应该尽量****<font style="color:#000000;">与CPU核心数保持一致</font>****。一般****<font style="color:rgba(251,11,138,0.44);">推荐</font>****将核心线程数****<font style="color:rgba(251,11,138,0.44);">设置为CPU核心数+1</font>****，这样可以充分利用CPU的计算能力，并且提供一个额外的线程用于防止CPU饥饿。**
+ **对于****<font style="color:rgba(251,11,138,0.44);">IO密集型任务</font>****，虽然这类任务并不会特别消耗CPU资源，但是在进行IO操作时会占用较多时间。因此，可以****<font style="color:rgba(251,11,138,0.44);">适当增加线程池的核心线程数</font>****，一般****<font style="color:rgba(251,11,138,0.44);">推荐</font>****将核心线程数设置为****<font style="color:rgba(251,11,138,0.44);">2倍CPU核心数</font>****。这样可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU的时间。**

# <font style="color:rgba(255,165,0,1);">23.线程池中线程复用原理</font>
**线程池中线程复用原理是通过****<font style="color:rgba(251,11,138,0.44);">封装工作线程并循环执行任务</font>****。**

**工作线程****<font style="color:rgba(251,11,138,0.44);">从任务队列</font>****获取新任务执行，****<font style="color:rgba(251,11,138,0.44);">避免了</font>****频繁创建和销毁线程，提高了系统的效率和性能。**

**线程池实现了****<font style="color:rgba(251,11,138,0.44);">线程的管理和调度</font>****，使得线程可以重复利用，****<font style="color:rgba(251,11,138,0.44);">减少了</font>****系统开销。**

**同时，线程池根据任务负载动态调整线程数量，适应不同需求。这种机制提升了系统的响应速度和吞吐量，提供了一种高效的并发处理方式。**

# <font style="color:rgba(255,165,0,1);">24.线程池中线程如何回收</font>
**线程池中线程的回收是通过****<font style="color:rgba(251,11,138,0.44);">设置空闲超时</font>****和****<font style="color:rgba(251,11,138,0.44);">最大线程数</font>****两种方式进行的。**

**<font style="color:#DF2A3F;">首先，</font>****如果一个线程在执行完任务后一段时间内****<font style="color:rgba(251,11,138,0.44);">没有新的任务可执行</font>****，根据设定的空闲超时时间，该线程会被回收。**

**<font style="color:#DF2A3F;">其次，</font>****当线程池中的线程数量已经****<font style="color:rgba(251,11,138,0.44);">达到最大线程数</font>****，并且所有****<font style="color:rgba(251,11,138,0.44);">线程都处于空闲状态</font>****时，多余的空闲线程****<font style="color:rgba(251,11,138,0.44);">会被回收</font>****以限制线程数量的增长。**

**这样的回收机制可以根据任务负载动态调整线程数量，提高系统的效率和资源利用率，并避免不必要的资源浪费。**

# <font style="color:rgba(255,165,0,1);">25.常见的阻塞队列有哪些</font>
**常见的阻塞队列有以下几种：**

+ **<font style="color:#DF2A3F;">ArrayBlockingQueue：</font>****基于****<font style="color:rgba(251,11,138,0.44);">数组</font>****实现的有界阻塞队列，按照****<font style="color:rgba(251,11,138,0.44);">先进先出</font>****的原则进行操作。**
+ **<font style="color:#DF2A3F;">LinkedBlockingQueue：</font>****基于****<font style="color:rgba(251,11,138,0.44);">链表</font>****实现的可选有界或无界阻塞队列，也按照****<font style="color:rgba(251,11,138,0.44);">先进先出</font>****的原则进行操作。**
+ **<font style="color:#DF2A3F;">PriorityBlockingQueue：</font>****基于****<font style="color:rgba(251,11,138,0.44);">堆结构</font>****实现的优先级阻塞队列，元素按照****<font style="color:rgba(251,11,138,0.44);">优先级进行排序</font>****。**
+ **<font style="color:#DF2A3F;">SynchronousQueue：</font>****一个****<font style="color:rgba(251,11,138,0.44);">不存储元素</font>****的阻塞队列，用于线程间的****<font style="color:rgba(251,11,138,0.44);">直接传输</font>****。**
+ **<font style="color:#DF2A3F;">DelayQueue：</font>****基于****<font style="color:rgba(251,11,138,0.44);">优先级队列</font>****实现的延时阻塞队列，元素按照指定的****<font style="color:rgba(251,11,138,0.44);">延时时间</font>****进行处理。**

**这些阻塞队列在多线程编程中提供了方便的数据共享和同步机制，能够有效地管理线程之间的任务调度和通信。**

# <font style="color:rgba(255,165,0,1);">26.Volatile关键字的作用</font>
**Volatile 关键字保证了多线程环境下变量的****<font style="color:rgba(251,11,138,0.44);">可见性</font>****和****<font style="color:rgba(251,11,138,0.44);">禁止指令重排序</font>****。**

**通过将变量声明为 Volatile，对该变量的修改操作会****<font style="color:rgba(251,11,138,0.44);">立即写入</font>****主内存，并且其他线程在访问该变量时会从主内存中获取最新值，****<font style="color:rgba(251,11,138,0.44);">解决了</font>****线程之间的****<font style="color:rgba(251,11,138,0.44);">数据不一致问题</font>****。**

**<font style="color:#DF2A3F;">此外，</font>****volatile 关键字还能****<font style="color:rgba(251,11,138,0.44);">禁止</font>****编译器和处理器对被标记变量的****<font style="color:rgba(251,11,138,0.44);">指令重排序</font>****优化，确保程序执行顺序的正确性。**

**<font style="color:#DF2A3F;">需要注意的是，</font>****volatile 关键字****<font style="color:rgba(251,11,138,0.44);">不能替代锁</font>****，它只能保证可见性和禁止重排序。**

#  <font style="color:rgba(255,165,0,1);">27.Java内存模型是怎样的</font>
**Java内存模型规定了Java程序中****<font style="color:rgba(251,11,138,0.44);">多线程之间的内存访问规则</font>****。**

**它包含****<font style="color:rgba(251,11,138,0.44);">主内存</font>****和****<font style="color:rgba(251,11,138,0.44);">线程本地工作内存</font>****，通过写入主内存和从主内存读取数据来实现****<font style="color:rgba(251,11,138,0.44);">多线程间</font>****的****<font style="color:rgba(251,11,138,0.44);">数据共享与通信</font>****。**

**内存模型通过****<font style="color:rgba(251,11,138,0.44);">先行发生原则</font>****保证操作顺序性，并使用****<font style="color:rgba(251,11,138,0.44);">volatile关键字</font>****确保可见性和禁止指令重排序，使用****<font style="color:rgba(251,11,138,0.44);">synchronized关键字</font>****用于实现互斥同步。**

**内存模型的规则保证了多线程环境下数据的一致性和线程安全。开发者应遵守这些规则以确保正确的并发程序行为。**

# <font style="color:rgba(255,165,0,1);">28.保证线程安全的常用方法</font>
1. **<font style="color:#DF2A3F;">使用锁机制：</font>****使用关键字****<font style="color:rgba(251,11,138,0.44);">synchronized</font>****或****<font style="color:rgba(251,11,138,0.44);">Lock接口</font>****及其实现类对关键代码块或方法进行****<font style="color:rgba(251,11,138,0.44);">加锁</font>****，确保同一时间只有一个线程能够执行，避免数据竞争和不一致性。**
2. **<font style="color:#DF2A3F;">使用原子类：</font>****使用AtomicInteger、AtomicLong等原子类，利用底层的****<font style="color:rgba(251,11,138,0.44);">CAS </font>****操作实现****<font style="color:rgba(251,11,138,0.44);">线程安全的原子操作</font>****。**
3. **<font style="color:#DF2A3F;">使用并发容器：</font>****使用java.util.concurrent包中提供的****<font style="color:rgba(251,11,138,0.44);">线程安全的集合类</font>****，如ConcurrentHashMap、CopyOnWriteArrayList等**
4. **<font style="color:#DF2A3F;">使用ThreadLocal：</font>****使用ThreadLocal类为每个线程****<font style="color:rgba(251,11,138,0.44);">提供独立的变量副本</font>****，确保线程间数据的隔离性，避免线程安全问题。**

# <font style="color:rgba(255,165,0,1);">29.什么是 CAS？</font>
**CAS（Compare and Swap）是一种****<font style="color:rgba(251,11,138,0.44);">并发控制机制</font>****，用于****<font style="color:rgba(251,11,138,0.44);">解决并发</font>****环境下****<font style="color:rgba(251,11,138,0.44);">的数据竞争</font>****和****<font style="color:rgba(251,11,138,0.44);">原子性问题</font>****。**

**它允许多个线程或进程同时访问共享资源，并且通过****<font style="color:rgba(251,11,138,0.44);">比较当前值与预期值</font>****是否相等来****<font style="color:rgba(251,11,138,0.44);">判断</font>****是否进行更新操作。**

**<font style="color:#DF2A3F;">如果相等</font>****，就将新值写入内存地址；**

**<font style="color:#DF2A3F;">如果不相等</font>****，则操作失败，需要重新尝试。**

**CAS操作被广泛应用于并发编程中的自旋锁、无锁数据结构等场景，提高了线程安全和性能。**

**然而，CAS也存在一些限制，如ABA问题和循环时间长。**

# <font style="color:rgba(255,165,0,1);">30.CAS 有哪些优缺点?</font>
**CAS的优点包括：**

+ **<font style="color:#DF2A3F;">原子性：</font>****CAS操作是****<font style="color:rgba(251,11,138,0.44);">原子性</font>****的，可以****<font style="color:rgba(251,11,138,0.44);">避免</font>****数据竞争和同步问题。**
+ **<font style="color:#DF2A3F;">高效性：</font>****相较于传统锁机制，CAS操作****<font style="color:rgba(251,11,138,0.44);">不需要</font>****进行加锁和解锁操作，因此执行****<font style="color:rgba(251,11,138,0.44);">效率更高</font>****。**
+ **<font style="color:#DF2A3F;">无阻塞：</font>****CAS操作是****<font style="color:rgba(251,11,138,0.44);">非阻塞</font>****的，线程不会在等待锁上浪费时间。**

**但CAS也存在以下缺点：**

+ **<font style="color:#DF2A3F;">ABA问题：</font>****CAS****<font style="color:rgba(251,11,138,0.44);">无法解决</font>****ABA问题（一个值被修改为另一个值，然后又被改回原来的值），可能导致数据不一致。**
+ **<font style="color:#DF2A3F;">忙等待：</font>****由于CAS失败时****<font style="color:rgba(251,11,138,0.44);">需要重试</font>****，循环时间长而且开销大，可能导致忙等待问题。**
+ **<font style="color:#DF2A3F;">非确定性：</font>****由于多个线程可能同时尝试进行CAS操作，因此无法确定哪个线程最终能够成功。**

# <font style="color:rgba(255,165,0,1);">31.悲观锁和乐观锁的区别</font>
**悲观锁和乐观锁是并发控制的两种不同策略。**

**<font style="color:#DF2A3F;">悲观锁：</font>**

**在整个数据访问过程中，****<font style="color:rgba(251,11,138,0.44);">假设会出现并发冲突</font>****，因此采取保守的策略，****<font style="color:rgba(251,11,138,0.44);">使用锁</font>****来阻塞其他线程对共享资源的访问。**

**悲观锁在读取和修改数据时会直接加锁，确保数据的完整性和一致性。**

**<font style="color:#DF2A3F;">乐观锁：</font>**

**在整个数据访问过程中，****<font style="color:rgba(251,11,138,0.44);">假设不会出现并发冲突</font>****，因此****<font style="color:rgba(251,11,138,0.44);">不主动加锁</font>****，而是****<font style="color:rgba(251,11,138,0.44);">采用版本控制</font>****或者****<font style="color:rgba(251,11,138,0.44);">比较交换</font>****的方式来****<font style="color:rgba(251,11,138,0.44);">检测</font>****是否发生了冲突。如果没有冲突，则更新数据，否则进行回滚或重试。**

**乐观锁适用于多读少写的场景，避免了加锁的开销，提高了并发性能。但是，乐观锁需要处理冲突的情况，可能需要重试操作。**

# <font style="color:rgba(255,165,0,1);">32.公平锁和非公平锁的区别</font>
**公平锁和非公平锁是线程调度中的****<font style="color:rgba(251,11,138,0.44);">两种不同策略</font>****。**

**<font style="color:#DF2A3F;">公平锁</font>****是指多个线程按照请求的顺序获得锁，即****<font style="color:rgba(251,11,138,0.44);">先到先得的原则</font>****。当一个线程释放锁后，等待时间最长的线程将获得锁的访问权。公平锁可以****<font style="color:rgba(251,11,138,0.44);">避免饥饿现象</font>****，但可能会导致线程切换的频繁发生，****<font style="color:rgba(251,11,138,0.44);">降低系统的吞吐量</font>****。**

**<font style="color:#DF2A3F;">非公平锁</font>****是指多个线程争抢锁时，****<font style="color:rgba(251,11,138,0.44);">不考虑等待的顺序</font>****，直接尝试获取锁。如果获取失败，则进入等待队列，等待被唤醒后再次竞争锁。****<font style="color:rgba(251,11,138,0.44);">非公平锁</font>****在****<font style="color:rgba(251,11,138,0.44);">性能</font>****上通常****<font style="color:rgba(251,11,138,0.44);">优于公平锁</font>****，因为它****<font style="color:rgba(251,11,138,0.44);">减少了线程切换的开销</font>****，但可能会导致某些线程长期等待。**

# <font style="color:rgba(255,165,0,1);">33.synchronized 和ReentrantLock区别？</font>
**synchronized 和 ReentrantLock 都可以用于多线程下的同步控制，但具有如下不同点：**

1. **<font style="color:#DF2A3F;">线程阻塞机制不同：</font>****synchronized 在****<font style="color:rgba(251,11,138,0.44);">获取锁失败</font>****时会****<font style="color:rgba(251,11,138,0.44);">一直等待</font>****，而 ReentrantLock 支持可****<font style="color:rgba(251,11,138,0.44);">中断式</font>****获取锁。**
2. **<font style="color:#DF2A3F;">对于公平锁的支持</font>****：synchronized ****<font style="color:rgba(251,11,138,0.44);">无法实现公平锁</font>****，而 ReentrantLock 可以通过构造函数****<font style="color:rgba(251,11,138,0.44);">传入 true 来实现</font>****公平锁。**
3. **<font style="color:#DF2A3F;">性能方面不同：</font>****在****<font style="color:rgba(251,11,138,0.44);">低并发的情况</font>****下，synchronized 的性能比 ReentrantLock 好，因为它是 JVM 层面的锁，不需要进行用户态和内核态之间的切换。但在****<font style="color:rgba(251,11,138,0.44);">高并发的情况</font>****下，ReentrantLock 的性能优于 synchronized，因为它提供了更灵活的线程控制，可以有效地避免死锁。**

# <font style="color:rgba(255,165,0,1);">34.ThreadLocal数据存储原理？</font>
**ThreadLocal 中的数据实际上是****<font style="color:rgba(251,11,138,0.44);">存储在每个线程</font>****的 Thread 对象中的一个****<font style="color:rgba(251,11,138,0.44);">特殊的字段</font>****中，称为 ****<font style="color:rgba(251,11,138,0.44);">ThreadLocalMap</font>****。**

**每个线程****<font style="color:rgba(251,11,138,0.44);">都有自己独立</font>****的ThreadLocalMap****<font style="color:rgba(251,11,138,0.44);">用于存储</font>****对应的ThreadLocal变量及其值。**

**ThreadLocalMap 是一个自定义的****<font style="color:rgba(251,11,138,0.44);">散列表</font>****，其****<font style="color:rgba(251,11,138,0.44);">键为</font>**** ThreadLocal 实例，****<font style="color:rgba(251,11,138,0.44);">值为</font>****对应的变量值。****<font style="color:rgba(251,11,138,0.44);">每个线程</font>****访问 ThreadLocal 时，实际上是通过 ThreadLocalMap 查找或修改对应的值。**

**由于每个线程的 ThreadLocalMap ****<font style="color:rgba(251,11,138,0.44);">是独立的</font>****，因此可以实现****<font style="color:rgba(251,11,138,0.44);">线程间数据隔离</font>****的效果。**

**当一个****<font style="color:rgba(251,11,138,0.44);">线程结束</font>****时，它持有的 ThreadLocalMap 也****<font style="color:rgba(251,11,138,0.44);">会被回收</font>****，从而实现对应的 ThreadLocal 的数据的释放，避免内存泄漏问题。**

**需要注意的是，ThreadLocal 中存储的数据****<font style="color:rgba(251,11,138,0.44);">仅在当前线程内部可见</font>****，不会被其他线程访问到，因此能够保证多线程环境下的数据隔离和线程安全性。**

# <font style="color:rgba(255,165,0,1);">35.Error和Exception的区别</font>
**Error 和 Exception 是两种可抛出对象，区别如下：**

+ **<font style="color:#262626;">Error </font>****表示****<font style="color:rgba(251,11,138,0.44);">严重的系统或环境错误，</font>****<font style="color:#262626;">无法恢复</font>****。**
+ **<font style="color:#262626;">Exception </font>****可由开发者****<font style="color:rgba(251,11,138,0.44);">代码引发</font>****，分为****<font style="color:rgba(251,11,138,0.44);">受检异常</font>****和****<font style="color:rgba(251,11,138,0.44);">非受检异常</font>****。**
    - **<font style="color:#262626;">受检异常</font>****需要在方法签名中声明或进行捕获和处理。**
    - **非受检异常不要求声明或强制捕获处理。**

# <font style="color:rgba(255,165,0,1);">36.continue 和 break 的区别</font>
**continue 和 break 是两个在编程语言中常用的关键字，它们的作用和区别如下：**

+ **<font style="color:#DF2A3F;">continue：</font>****continue 关键字****<font style="color:rgba(251,11,138,0.44);">用于循环语句</font>****中，是用于****<font style="color:rgba(251,11,138,0.44);">跳过当前迭代的剩余代码</font>****并开始下一次迭代，换句话说，它会忽略 continue 语句后面的代码，直接进行下一轮的循环。**
+ **<font style="color:#DF2A3F;">break：</font>****break 关键字同样****<font style="color:rgba(251,11,138,0.44);">用于循环语句</font>****中，是用于****<font style="color:rgba(251,11,138,0.44);">提前终止循环并跳出循环体</font>****。当程序执行到 break 语句时，它将立即停止当前循环的执行，并跳出整个循环体，继续执行循环外的代码。**

# <font style="color:rgba(255,165,0,1);">37.Java 4种引用的区别</font>
**Java中有四种引用类型：****<font style="color:rgba(251,11,138,0.44);">强引用</font>****、****<font style="color:rgba(251,11,138,0.44);">软引用</font>****、****<font style="color:rgba(251,11,138,0.44);">弱引用</font>****和****<font style="color:rgba(251,11,138,0.44);">虚引用</font>****。它们之间的****<font style="color:rgba(251,11,138,0.44);">区别</font>****主要在于****<font style="color:rgba(251,11,138,0.44);">对垃圾回收的影响和回收优先级</font>****，具体如下：**

+ **强引用是默认类型，不受垃圾回收的影响；**
+ **软引用在内存不足时可能被回收；**
+ **弱引用的回收优先级更低，只要没有强引用指向对象，就可能被回收；**
+ **虚引用主要用于跟踪对象被回收的状态。**

# <font style="color:rgba(255,165,0,1);">38.什么是 CLH 锁</font>
**CLH锁是一种****<font style="color:rgba(251,11,138,0.44);">自旋锁</font>****的变种，用于实现对共享资源的互斥访问。**

**它通过****<font style="color:rgba(251,11,138,0.44);">链表的形式</font>****组织等待线程，并采用****<font style="color:rgba(251,11,138,0.44);">自旋等待</font>****的方式，以提高性能和公平性。**

**相比传统的自旋锁，CLH锁****<font style="color:rgba(251,11,138,0.44);">减少了</font>****处理器缓存竞争，并****<font style="color:rgba(251,11,138,0.44);">避免了</font>****忙等待的问题。**

**然而，在高并发场景下可能出现伸缩性问题，所以在高并发场景下需要注意选择合适的锁机制。**

# <font style="color:rgba(255,165,0,1);">39.单例模式的懶汉式和饿汉式</font>
**懒汉式和饿汉式是两种常见的单例模式实现方式，用于确保一个类只有一个实例对象。****<font style="color:rgba(251,11,138,0.44);"></font>**

**<font style="color:#DF2A3F;">懒汉式：</font>**

+ **在需要获取单例实例时才进行初始化，****<font style="color:rgba(251,11,138,0.44);">延迟实例化</font>****。**
+ **优点是****<font style="color:rgba(251,11,138,0.44);">实现简单</font>****且延迟初始化，但在****<font style="color:rgba(251,11,138,0.44);">多线程</font>****环境下****<font style="color:rgba(251,11,138,0.44);">需要考虑</font>****线程安全性，并可能降低并发性能。**

**<font style="color:#DF2A3F;">饿汉式：</font>**

+ **在类加载时就进行对象的创建，即在****<font style="color:rgba(251,11,138,0.44);">类定义</font>****时就****<font style="color:rgba(251,11,138,0.44);">实例化单例对象</font>****。**
+ **优点是实现****<font style="color:rgba(251,11,138,0.44);">简单且线程安全</font>****，但可能会造成****<font style="color:rgba(251,11,138,0.44);">资源浪费</font>****，特别是在单例对象占用内存较大或初始化耗时较长的情况下。**

# <font style="color:rgba(255,165,0,1);">40.什么情况下触发类加载</font>
**在Java中，以下几种情况会触发类的加载：**

+ **<font style="color:rgba(251,11,138,0.44);">创建类的实例；</font>****例如：MyClass obj = new MyClass();**
+ **<font style="color:rgba(251,11,138,0.44);">访问类的静态成员；</font>****例如：int value = MyClass.staticVariable; **
+ **<font style="color:rgba(251,11,138,0.44);">调用类的静态方法；</font>****例如：MyClass.staticMethod();**
+ **<font style="color:rgba(251,11,138,0.44);">使用反射操作；</font>****例如：Class.forName("com.example.MyClass")**
+ **<font style="color:rgba(251,11,138,0.44);">执行Java程序的入口类</font>****：通常是含有public static void main(String[] args)方法的类**

# <font style="color:rgba(255,165,0,1);">41.有哪几种类加载器</font>
**Java中存在以下几种类加载器：**

+ **<font style="color:rgba(251,11,138,0.44);">启动类加载器：</font>****负责加载Java核心类库。**
+ **<font style="color:rgba(251,11,138,0.44);">扩展类加载器：</font>****加载Java扩展库。**
+ **<font style="color:rgba(251,11,138,0.44);">应用程序类加载器：</font>****加载应用程序类路径上的类。**

# <font style="color:rgba(255,165,0,1);">42.什么是双亲委派机制</font>
**双亲委派机制是Java****<font style="color:rgba(251,11,138,0.44);">类加载器</font>****的一种****<font style="color:rgba(251,11,138,0.44);">工作方式</font>****。**

**它规定, 在一个特定的类加载器接收到类加载请求时，该加载器首先会把这个****<font style="color:rgba(251,11,138,0.44);">请求委托</font>****给它的****<font style="color:rgba(251,11,138,0.44);">父类</font>****加载器去完成，直到****<font style="color:rgba(251,11,138,0.44);">到达最顶层</font>****的启动类加载器。只有在****<font style="color:rgba(251,11,138,0.44);">父类</font>****加载器****<font style="color:rgba(251,11,138,0.44);">无法完成</font>****加载请求的情况下，子加载器才会自己去尝试加载。**

**这种双亲委派的过程****<font style="color:rgba(251,11,138,0.44);">保证了</font>****Java类的唯一性，****<font style="color:rgba(251,11,138,0.44);">避免了</font>****重复加载。同时，由于Java类的加载过程是逐级向上委托的，所以可以保证Java类的****<font style="color:rgba(251,11,138,0.44);">安全性</font>****。**

# <font style="color:rgba(255,165,0,1);">43.如何打破双亲委派机制</font>
**要打破双亲委派机制，可以****<font style="color:rgba(251,11,138,0.44);">自定义一个类加载器</font>****，并在其加载类的逻辑中不遵循双亲委派规则。具体步骤如下：**

+ **<font style="color:rgba(251,11,138,0.44);">创建</font>****一个继承于 java.lang.ClassLoader****<font style="color:rgba(251,11,138,0.44);">自定义类加载器</font>****。**
+ **<font style="color:rgba(251,11,138,0.44);">重写findClass()方法</font>****，在该方法中实现特定的类加载逻辑。可以从非标准的位置加载类文件、修改加载规则等。**
+ **在加载类时，通过****<font style="color:rgba(251,11,138,0.44);">调用defineClass()</font>****方法将字节码数据转换为类对象。**
+ **调用自定义类加载器的****<font style="color:rgba(251,11,138,0.44);">loadClass()方法</font>****来加载需要的类。**

# <font style="color:rgba(255,165,0,1);">44.深拷贝和浅拷贝区别</font>
**深拷贝和浅拷贝是在对象复制过程中的两种不同方式：**

+ **浅拷贝是****<font style="color:rgba(251,11,138,0.44);">复制对象的引用</font>****，新对象和原对象****<font style="color:rgba(251,11,138,0.44);">共享</font>****一块****<font style="color:rgba(251,11,138,0.44);">内存地址</font>****；**
+ **深拷贝是****<font style="color:rgba(251,11,138,0.44);">复制对象本身的内容</font>****，新对象与原对象****<font style="color:rgba(251,11,138,0.44);">独立</font>****，彼此之间****<font style="color:rgba(251,11,138,0.44);">没有</font>****任何****<font style="color:rgba(251,11,138,0.44);">关联</font>****。**

**在进行深拷贝时，需要注意可能会涉及到递归复制子对象的所有属性，可能会引起性能上的开销。**

# <font style="color:rgba(255,165,0,1);">45.JDK动态代理与CGLIB的区别</font>
**JDK动态代理和CGLIB动态代理是Java中两种常见的实现动态代理的方式。**

+ **<font style="color:#DF2A3F;">JDK动态代理</font>****适用于那些****<font style="color:rgba(251,11,138,0.44);">实现了接口的类</font>****。使用Java标准库，****<font style="color:rgba(251,11,138,0.44);">无需额外依赖</font>****，在运行时通过反射机制调用被代理对象的方法。**
+ **<font style="color:#DF2A3F;">CGLIB动态代理</font>****则适用于****<font style="color:rgba(251,11,138,0.44);">没有实现接口的类</font>****。它使用****<font style="color:rgba(251,11,138,0.44);">字节码生成库cglib</font>****来生成代理类。CGLIB动态代理通过继承被代理类并重写其方法，并在运行时动态生成字节码来实现代理。**

**相对而言，****<font style="color:rgba(251,11,138,0.44);">JDK动态代理更轻量级</font>****，因为它使用Java标准库，无需引入额外依赖。而****<font style="color:rgba(251,11,138,0.44);">CGLIB动态代理</font>****在生成代理类时需要动态生成字节码，所以相对来说****<font style="color:rgba(251,11,138,0.44);">更重量级一些</font>****。**

# <font style="color:rgba(255,165,0,1);">46.什么是Java的序列化</font>
**Java的序列化是将****<font style="color:rgba(251,11,138,0.44);">对象转换为字节流的过程</font>****，以便在网络传输、存储或跨平台传递。**

+ **通过****<font style="color:rgba(251,11,138,0.44);">实现Serializable接口</font>****，对象****<font style="color:rgba(251,11,138,0.44);">可以被序</font>****列化和反序列化。**
+ **序列化****<font style="color:rgba(251,11,138,0.44);">可用于</font>****远程通信、缓存和对象持久化等场景。**
+ **序列化后的对象可以在不同环境中传输，并在接收端重新恢复为原始对象。**

**序列化使对象的跨平台和跨网络****<font style="color:rgba(251,11,138,0.44);">传输变得</font>****简单和方便。**

# <font style="color:rgba(255,165,0,1);">47.什么是守护线程？与普通线程的区别是什么</font>
**守护线程是一种****<font style="color:rgba(251,11,138,0.44);">在程序后台</font>****提供支持服务的****<font style="color:rgba(251,11,138,0.44);">特殊线程类型</font>****。**

**与普通线程相比，它具有****<font style="color:rgba(251,11,138,0.44);">生命周期上的区别</font>****，当所有用户线程结束时自动终止；它的****<font style="color:rgba(251,11,138,0.44);">角色定位也不同</font>****，通常用于执行某些后台任务，以提供支持性的功能。**

**需要注意它不能执行关键任务并且不能访问非守护线程创建的资源。**

# <font style="color:rgba(255,165,0,1);">48.说说你对设计模式的理解</font>
**设计模式是软件设计中常见问题的****<font style="color:rgba(251,11,138,0.44);">解决方案经验总结</font>****，具有****<font style="color:rgba(251,11,138,0.44);">可重用</font>****、****<font style="color:rgba(251,11,138,0.44);">易扩展</font>****和****<font style="color:rgba(251,11,138,0.44);">易维护</font>****的优势，合理运用设计模式能提高代码质量、可读性和可维护性。**

**然而，设计模式****<font style="color:rgba(251,11,138,0.44);">并非万能药</font>****，应根据实际需求慎重选择，并结合良好的设计原则使用。只有在恰当的情况下，才能发挥设计模式的最大价值，提升软件系统的效率和可靠性。**

# <font style="color:rgba(255,165,0,1);">49.什么是指针碰撞</font>
**指针碰撞是一种****<font style="color:rgba(251,11,138,0.44);">内存分配</font>****的方式，适用于特定的内存管理场景。**

**它将****<font style="color:rgba(251,11,138,0.44);">内存</font>****视为****<font style="color:rgba(251,11,138,0.44);">连续</font>****的区域，通过一个****<font style="color:rgba(251,11,138,0.44);">指针标记</font>****可用的内存地址，并在每次分配内存时将指针移动到下一个可用地址。**

**这样，每个分配的内存块都相邻连接。指针碰撞要求原子操作来确保并发下的内存分配****<font style="color:rgba(251,11,138,0.44);">不会产生冲突</font>****。**

**然而，指针碰撞只适用于****<font style="color:rgba(251,11,138,0.44);">静态分配</font>****或****<font style="color:rgba(251,11,138,0.44);">预先知道</font>****内存大小的动态分配，且****<font style="color:rgba(251,11,138,0.44);">无法处理</font>****内存重叠的情况。**

# <font style="color:rgba(255,165,0,1);">50.什么是TLAB</font>
**TLAB是线程****<font style="color:rgba(251,11,138,0.44);">本地分配缓冲区</font>****，一种****<font style="color:rgba(251,11,138,0.44);">提高</font>****多线程程序中堆内存分配性能的技术。**

**Java虚拟机为每个线程都****<font style="color:rgba(251,11,138,0.44);">分配自己的TLAB</font>****，将堆内存划分为多个固定大小的区域。**

**当线程进行内存分配时，可以直接****<font style="color:rgba(251,11,138,0.44);">在自己</font>****的TLAB中进行，****<font style="color:rgba(251,11,138,0.44);">减少</font>****全局堆锁的竞争，提高效率。**

**使用TLAB可以****<font style="color:rgba(251,11,138,0.44);">有效避免</font>****因内存分配而导致的线程间竞争，****<font style="color:rgba(251,11,138,0.44);">但需要</font>****合理配置大小和分配策略。**

# <font style="color:rgba(255,165,0,1);">51.MySQL 索引类型</font>
**MySQL****<font style="color:rgba(251,11,138,0.44);">索引类型包括</font>****B树索引、哈希索引、全文索引、空间索引和组合索引。**

**<font style="color:rgba(251,11,138,0.44);">B树索引</font>****适用于大多数查询场景，****<font style="color:rgba(251,11,138,0.44);">哈希索引</font>****适用于等值查询，****<font style="color:rgba(251,11,138,0.44);">全文索引</font>****用于全文搜索，****<font style="color:rgba(251,11,138,0.44);">空间索引</font>****用于地理空间数据，****<font style="color:rgba(251,11,138,0.44);">组合索引</font>****可以提高多列查询的效率。**

**选择适当的索引类型可以优化数据库的查询性能。**

# <font style="color:rgba(255,165,0,1);">52.组合索引的最左前缀匹配原则</font>
**组合索引的最左前缀匹配原则是指在****<font style="color:rgba(251,11,138,0.44);">使用组合索引</font>****进行查询时，****<font style="color:rgba(251,11,138,0.44);">只能利用</font>****索引的****<font style="color:rgba(251,11,138,0.44);">最左边的列</font>****进行匹配，****<font style="color:rgba(251,11,138,0.44);">无法利用</font>****索引的右边列进行匹配。**

**这是由于组合索引的存储结构决定的。**

**因此，在设计组合索引时，应将经常用于查询条件的列放在左边，以提高查询效率。**

# <font style="color:rgba(255,165,0,1);">53.隐式转换导致索引失效</font>
**隐式转换导致索引失效的原因主要是由于****<font style="color:rgba(251,11,138,0.44);">数据类型不匹配</font>****和****<font style="color:rgba(251,11,138,0.44);">函数操作</font>****。当查询条件中的列的数据类型与索引列的数据****<font style="color:rgba(251,11,138,0.44);">类型不一致</font>****，或者在查询条件中对列进行了****<font style="color:rgba(251,11,138,0.44);">函数操作</font>****时，MySQL 会尝试进行****<font style="color:rgba(251,11,138,0.44);">隐式转换</font>****。**

**然而，****<font style="color:rgba(251,11,138,0.44);">转换后</font>****的数据类型可能与索引列的数据****<font style="color:rgba(251,11,138,0.44);">类型不匹配</font>****，导致索引****<font style="color:rgba(251,11,138,0.44);">无法使用</font>****。**

**为避免这种情况，应确保查询条件中的列与索引列的数据类型匹配，并尽量****<font style="color:rgba(251,11,138,0.44);">避免</font>****在查询条件中对列进行函数操作。通过****<font style="color:rgba(251,11,138,0.44);">优化数据类型</font>****和查询条件，可以****<font style="color:rgba(251,11,138,0.44);">提高</font>****索引的效率，****<font style="color:rgba(251,11,138,0.44);">提升</font>****查询性能。**

# <font style="color:rgba(255,165,0,1);">54.哈希索引的缺点是什么</font>
**哈希索引的缺点主要包括以下几点：**

+ **<font style="color:rgba(251,11,138,0.44);">仅支持</font>****等值查询，****<font style="color:rgba(251,11,138,0.44);">无法进行</font>****范围查询、排序或模糊匹配。**
+ **无序存储导致****<font style="color:rgba(251,11,138,0.44);">无法按顺序访问</font>****数据。**
+ **<font style="color:rgba(251,11,138,0.44);">处理</font>****重复键值效率低下。**
+ **对内存****<font style="color:rgba(251,11,138,0.44);">要求较高</font>****，需要一次性加载到内存。**
+ **<font style="color:rgba(251,11,138,0.44);">占用较大</font>****的存储空间。**

# <font style="color:rgba(255,165,0,1);">55.索引失效的几种场景</font>
**索引失效可能是由以下因素引起的：**

+ **查询条件****<font style="color:rgba(251,11,138,0.44);">不使用</font>****索引列。**
+ **多个条件****<font style="color:rgba(251,11,138,0.44);">使用OR</font>****连接且其中****<font style="color:rgba(251,11,138,0.44);">至少一个</font>****条件不是索引列。**
+ **索引列****<font style="color:rgba(251,11,138,0.44);">基数非常高</font>****。**
+ **使用****<font style="color:rgba(251,11,138,0.44);">NOT操作</font>****导致对索引列进行****<font style="color:rgba(251,11,138,0.44);">反向查询</font>****。**
+ **数据分布****<font style="color:rgba(251,11,138,0.44);">不均匀</font>****。**

# <font style="color:rgba(255,165,0,1);">56.创建索引的原则</font>
+ **<font style="color:#DF2A3F;">选择合适的索引列：</font>****选择经****<font style="color:rgba(251,11,138,0.44);">常用</font>****于查询和条件筛选的列****<font style="color:rgba(251,11,138,0.44);">作为索引列</font>****，确保索引具有高选择性。**
+ **<font style="color:#DF2A3F;">考虑多列索引：</font>****对于****<font style="color:rgba(251,11,138,0.44);">经常</font>****一起使用的多个列，创建****<font style="color:rgba(251,11,138,0.44);">联合索引</font>****，提高多列条件查询的效率。**
+ **<font style="color:#DF2A3F;">确保索引区分度高：</font>****选择具有较多不同值的索引列，以****<font style="color:rgba(251,11,138,0.44);">减小</font>****索引范围，****<font style="color:rgba(251,11,138,0.44);">提高</font>****查询速度。**
+ **<font style="color:#DF2A3F;">避免过多索引：</font>****根据业务需求，选择性地****<font style="color:rgba(251,11,138,0.44);">创建必要的索引</font>****，****<font style="color:rgba(251,11,138,0.44);">避免过多</font>****索引增加维护成本和降低更新性能。**

# <font style="color:rgba(255,165,0,1);">57.B+树结构的优点</font>
+ **<font style="color:#DF2A3F;">平衡性：</font>****B+树保持树的平衡，使得查询、插入和删除操作的****<font style="color:rgba(251,11,138,0.44);">时间复杂度</font>****保持在****<font style="color:rgba(251,11,138,0.44);">较低</font>****水平。**
+ **<font style="color:#DF2A3F;">顺序访问性：</font>****B+树的节点按****<font style="color:rgba(251,11,138,0.44);">顺序存储</font>****，****<font style="color:rgba(251,11,138,0.44);">有利于</font>****范围查询和排序查询的性能。**
+ **<font style="color:#DF2A3F;">快速查找：</font>****B+树采用****<font style="color:rgba(251,11,138,0.44);">多层索引</font>****，能****<font style="color:rgba(251,11,138,0.44);">快速定位</font>****到目标数据。**
+ **<font style="color:#DF2A3F;">适应动态更新：</font>****B+树具有****<font style="color:rgba(251,11,138,0.44);">自平衡特性</font>****，适应数据的动态变化。**
+ **<font style="color:#DF2A3F;">扩展性：</font>****B+树支持存储大量数据，****<font style="color:rgba(251,11,138,0.44);">具有</font>****良好的扩展能力。**

# <font style="color:rgba(255,165,0,1);">58.聚簇索引与非聚簇索引的区别</font>
+ **<font style="color:#DF2A3F;">存储方式：</font>****聚簇索引按照索引键的顺序排序并****<font style="color:rgba(251,11,138,0.44);">直接存储数据行</font>****，非聚簇索引将索引键和行指针****<font style="color:rgba(251,11,138,0.44);">分开存储</font>****。**
+ **<font style="color:#DF2A3F;">表内索引数量：</font>****一张表只能有****<font style="color:rgba(251,11,138,0.44);">一个</font>****聚簇索引，但可以有****<font style="color:rgba(251,11,138,0.44);">多个</font>****非聚簇索引。**
+ **<font style="color:#DF2A3F;">查询性能：</font>****聚簇索引****<font style="color:rgba(251,11,138,0.44);">适合</font>****范围查询和顺序访问，非聚簇索引需要先查找索引再获取数据行。**
+ **<font style="color:#DF2A3F;">插入和更新性能：</font>****插入和更新时，聚簇索引可能需要移动数据行，****<font style="color:rgba(251,11,138,0.44);">耗时较长</font>****；非聚簇索引只需修改索引，****<font style="color:rgba(251,11,138,0.44);">速度较快</font>****。**
+ **<font style="color:#DF2A3F;">索引大小：</font>****聚簇索引通常比非聚簇索引****<font style="color:rgba(251,11,138,0.44);">更大</font>****，因为它直接存储数据行。**

# <font style="color:#ECAA04;">59.什么是覆盖索引</font>
**覆盖索引是数据库中的一种****<font style="color:rgba(251,11,138,0.44);">特殊索引</font>****，简单而言就是****<font style="color:rgba(251,11,138,0.44);">查询列都是索引列</font>****。使用覆盖索引有如下好处：**

+ **<font style="color:#DF2A3F;">减少IO访问：</font>****<font style="color:rgba(251,11,138,0.44);">减少了</font>****磁盘和内存的读取操作，因为数据可以直接从索引中获取，****<font style="color:rgba(251,11,138,0.44);">提高</font>****查询性能。**
+ **<font style="color:#DF2A3F;">减小存储开销：</font>****覆盖索引通常比包含整个数据行的索引更小，****<font style="color:rgba(251,11,138,0.44);">减少了</font>****存储占用。**
+ **<font style="color:#DF2A3F;">降低锁竞争：</font>****<font style="color:rgba(251,11,138,0.44);">减少</font>****锁竞争，****<font style="color:rgba(251,11,138,0.44);">提高</font>****多用户并发查询性能。**
+ **<font style="color:#DF2A3F;">提高查询性能：</font>****特别****<font style="color:rgba(251,11,138,0.44);">适用于</font>****复杂查询和大量数据，****<font style="color:rgba(251,11,138,0.44);">加速</font>****数据检索。**

# <font style="color:#ECAA04;">60.什么是索引下推</font>
**索引下推是一种数据库****<font style="color:rgba(251,11,138,0.44);">查询优化技术</font>****，通过在****<font style="color:rgba(251,11,138,0.44);">检索数据时</font>****尽早应用****<font style="color:rgba(251,11,138,0.44);">查询条件到索引层级</font>****，****<font style="color:rgba(251,11,138,0.44);">减少</font>****数据读取和内存占用。**

**它****<font style="color:rgba(251,11,138,0.44);">适用于</font>****大数据量、复杂查询条件和多表连接等场景，能够****<font style="color:rgba(251,11,138,0.44);">显著提升</font>****查询性能，****<font style="color:rgba(251,11,138,0.44);">加速</font>****数据检索和处理过程。**

**<font style="color:rgba(251,11,138,0.44);">注意，</font>****索引下推并非适用于所有查询和索引，需要根据具体情况确定可行性。**

# <font style="color:#ECAA04;">61.InnoDB和MyISAM的区别</font>
**InnoDB和MyISAM是MySQL数据库中****<font style="color:rgba(251,11,138,0.44);">常用的两种存储引擎</font>****，它们在性能、功能和适用场景等方面有以下区别：**

+ **<font style="color:#DF2A3F;">事务支持：</font>****<font style="color:rgba(251,11,138,0.44);">InnoDB支持</font>****事务处理，可以实现ACID特性，适用于需要并发读写和数据一致性要求高的场景。而MyISAM不支持事务，只支持表级锁定，适用于读密集的场景。**
+ **<font style="color:#DF2A3F;">并发性能：</font>****<font style="color:rgba(251,11,138,0.44);">InnoDB</font>****通过****<font style="color:rgba(251,11,138,0.44);">行级锁定</font>****实现高度的并发性能，多个事务可以同时操作不同的行。而****<font style="color:rgba(251,11,138,0.44);">MyISAM</font>****只支持****<font style="color:rgba(251,11,138,0.44);">表级锁定</font>****，当有查询或修改操作时，会锁定整个表，限制了并发性能。**
+ **<font style="color:#DF2A3F;">索引：</font>****<font style="color:rgba(251,11,138,0.44);">InnoDB</font>****的索引结构是****<font style="color:rgba(251,11,138,0.44);">B+树</font>****，支持聚簇索引，****<font style="color:rgba(251,11,138,0.44);">适合于</font>****频繁的查询和更新操作。****<font style="color:rgba(251,11,138,0.44);">MyISAM</font>****的索引结构是****<font style="color:rgba(251,11,138,0.44);">B树</font>****，不支持聚簇索引，****<font style="color:rgba(251,11,138,0.44);">适合于</font>****主要进行全文搜索的应用。**
+ **<font style="color:#DF2A3F;">容灾能力：</font>****<font style="color:rgba(251,11,138,0.44);">InnoDB</font>****支持崩溃恢复和故障容错能力，****<font style="color:rgba(251,11,138,0.44);">具备更好</font>****的数据安全性。****<font style="color:rgba(251,11,138,0.44);">MyISAM</font>****则较为脆弱，****<font style="color:rgba(251,11,138,0.44);">不具备</font>****崩溃恢复功能。当系统故障发生时，可能造成数据丢失或损坏。**

# <font style="color:#ECAA04;">62.什么是数据库事务</font>
**数据库事务是指作为****<font style="color:rgba(251,11,138,0.44);">单个逻辑工作单元</font>****执行的一组数据库操作，这些操作****<font style="color:rgba(251,11,138,0.44);">要么全部成功</font>****完成，****<font style="color:rgba(251,11,138,0.44);">要么全部失败</font>****回滚。事务以保证数据的一致性和完整性为目标。**

**事务具有以下几个特性，通常缩写为ACID：**

+ **<font style="color:#DF2A3F;">原子性（Atomicity）：</font>****事务中的所有操作****<font style="color:rgba(251,11,138,0.44);">要么全部执行</font>****成功，****<font style="color:rgba(251,11,138,0.44);">要么全部回滚</font>****，不会出现部分操作成功或部分操作失败的情况。**
+ **<font style="color:#DF2A3F;">一致性（Consistency）：</font>****事务在****<font style="color:rgba(251,11,138,0.44);">执行前后</font>****数据库的****<font style="color:rgba(251,11,138,0.44);">数据状态必须保持一致</font>****。如果一个事务违反了数据库的完整性约束，那么事务将回滚到执行之前的状态，保证数据的正确性。**
+ **<font style="color:#DF2A3F;">隔离性（Isolation）：</font>****<font style="color:rgba(251,11,138,0.44);">事务的执行</font>****是****<font style="color:rgba(251,11,138,0.44);">相互隔离</font>****的，一个事务的操作在提交之前对其他事务是不可见的。隔离级别可以控制事务之间的可见性和并发性。**
+ **<font style="color:#DF2A3F;">持久性（Durability）：</font>****一旦****<font style="color:rgba(251,11,138,0.44);">事务提交</font>****，其所做的修改会****<font style="color:rgba(251,11,138,0.44);">永久保存在数据库</font>****中，即使在系统故障或重启后，也能保证数据的持久性。**

# <font style="color:#ECAA04;">63.数据库并发会带来什么问题</font>
**数据库并发可能引起以下问题：**

1. **<font style="color:#DF2A3F;">脏读：</font>****一个事务****<font style="color:rgba(251,11,138,0.44);">读取未提交的数据</font>****，导致读取到无效或不正确的数据。**
2. **<font style="color:#DF2A3F;">不可重复读：</font>****一个事务在同一查询中****<font style="color:rgba(251,11,138,0.44);">多次读取数据</font>****，但其他事务对****<font style="color:rgba(251,11,138,0.44);">该数据</font>****进行了修改或删除，导致读取****<font style="color:rgba(251,11,138,0.44);">结果不一致</font>****。**
3. **<font style="color:#DF2A3F;">幻读：</font>****一个事务在****<font style="color:rgba(251,11,138,0.44);">同一查询中多次读取数据</font>****，但其他事务添加或删除了****<font style="color:rgba(251,11,138,0.44);">符合查询条件的数据</font>****，导致****<font style="color:rgba(251,11,138,0.44);">读取结果不一致</font>****。**
4. **<font style="color:#DF2A3F;">丢失更新：</font>****多个事务同时读取****<font style="color:rgba(251,11,138,0.44);">同一数据并进行修改</font>****，但****<font style="color:rgba(251,11,138,0.44);">只有一个</font>****事务的****<font style="color:rgba(251,11,138,0.44);">修改生效</font>****，其他事务的修改结果丢失。**
5. **<font style="color:#DF2A3F;">死锁：</font>****<font style="color:rgba(251,11,138,0.44);">多个事务</font>****相互****<font style="color:rgba(251,11,138,0.44);">等待对方释放资源</font>****，导致系统无法继续进行。**

**为解决这些问题，可以采用锁、事务隔离级别和并发控制算法等手段，以保证数据库在并发访问时仍能保持数据一致性和完整性。**

# <font style="color:#ECAA04;">64.MySQL 有几种锁机制</font>
**MySQL提供了多种锁机制，包括以下几种常见的锁：**

1. **<font style="color:#DF2A3F;">共享锁：</font>****也称为****<font style="color:rgba(251,11,138,0.44);">读锁</font>****，****<font style="color:rgba(251,11,138,0.44);">多个事务</font>****可以同时持有共享锁，****<font style="color:rgba(251,11,138,0.44);">用于</font>****读取数据而不进行修改，共享锁****<font style="color:rgba(251,11,138,0.44);">之间不会互斥</font>****。**
2. **<font style="color:#DF2A3F;">排他锁：</font>****也称为****<font style="color:rgba(251,11,138,0.44);">写锁</font>****，事务****<font style="color:rgba(251,11,138,0.44);">独占</font>****地持有排他锁，其他****<font style="color:rgba(251,11,138,0.44);">事务无法同时持有</font>****排他锁或共享锁，用于修改数据。**
3. **<font style="color:#DF2A3F;">记录锁：</font>********<font style="color:rgba(251,11,138,0.44);">锁定单个记录</font>****，其他事务无法修改该记录，但****<font style="color:rgba(251,11,138,0.44);">可以同时读取</font>****。**
4. **<font style="color:#DF2A3F;">间隙锁：</font>****<font style="color:rgba(251,11,138,0.44);">锁定</font>****一个范围的****<font style="color:rgba(251,11,138,0.44);">索引记录之间的间隙</font>****，防止新数据插入或删除。**
5. **<font style="color:#DF2A3F;">表级锁：</font>****最简单的锁机制，对整个****<font style="color:rgba(251,11,138,0.44);">表进行锁定</font>****，限制其他事务对整个表进行操作。**

**通过合理使用这些锁机制，可以在MySQL中实现并发控制，保证数据的一致性和完整性。**

# <font style="color:#ECAA04;">65.MySQL 事务隔离级别</font>
**MySQL提供了四种事务隔离级别，可以通过设置来控制事务的并发行为和数据一致性。**

1. **<font style="color:#DF2A3F;">读未提交（Read Uncommitted）</font>****：****<font style="color:rgba(251,11,138,0.44);">最低隔离级别</font>****，一个事务可以****<font style="color:rgba(251,11,138,0.44);">读取到其他事务尚未提交的数据</font>****，可能导致脏读、不可重复读和幻读的问题。**
2. **<font style="color:#DF2A3F;">读已提交（Read Committed）</font>****：一个事务****<font style="color:rgba(251,11,138,0.44);">只能读取到其他事务已经提交的数据</font>****，****<font style="color:rgba(251,11,138,0.44);">避免了</font>****脏读的问题，但仍可能导致不可重复读和幻读的问题。**
3. **<font style="color:#DF2A3F;">可重复读（Repeatable Read）</font>****：****<font style="color:rgba(251, 11, 138, 0.44);">默认的隔离级别</font>****<font style="color:rgb(38, 38, 38);">，</font>****确保在****<font style="color:rgba(251,11,138,0.44);">同一个事务</font>****中****<font style="color:rgba(251,11,138,0.44);">多次读取同样的数据</font>****时，会得到****<font style="color:rgba(251,11,138,0.44);">一致的结果</font>****。其他事务对数据的修改不可见，避免了脏读和不可重复读的问题，但仍可能导致幻读的问题。**
4. **<font style="color:#DF2A3F;">串行化（Serializable）：</font>****<font style="color:rgba(251,11,138,0.44);">最高隔离级别</font>****，将事务****<font style="color:rgba(251,11,138,0.44);">串行执行</font>****，确保数据的一致性。****<font style="color:rgba(251,11,138,0.44);">避免了</font>****所有并发问题，但****<font style="color:rgba(251,11,138,0.44);">牺牲了</font>****并发性能。**

# <font style="color:#ECAA04;">66.什么是 MVCC</font>
**MVCC是一种用于数据库系统的****<font style="color:rgba(251,11,138,0.44);">并发控制技术</font>****，它通过为每个事务****<font style="color:rgba(251,11,138,0.44);">创建独立的数据版本</font>****来****<font style="color:rgba(251,11,138,0.44);">实现</font>****事务隔离和一致性。**

**在MVCC中，事务可以****<font style="color:rgba(251,11,138,0.44);">读取和修改</font>****数据而****<font style="color:rgba(251,11,138,0.44);">不会相互冲突</font>****，并且读操作只能看到在其开始之前已经提交的版本。**

**当一个事务进行****<font style="color:rgba(251,11,138,0.44);">写操作</font>****时，MVCC会****<font style="color:rgba(251,11,138,0.44);">创建新的数据版本</font>****，****<font style="color:rgba(251,11,138,0.44);">其他事务</font>****仍然可以****<font style="color:rgba(251,11,138,0.44);">读取已提交的旧版本</font>****。**

**MVCC****<font style="color:rgba(251,11,138,0.44);">提高了</font>****并发性能，****<font style="color:rgba(251,11,138,0.44);">避免了</font>****一些锁竞争和阻塞问题，但也有存储开销和版本链过长的限制。**

**<font style="color:rgba(251,11,138,0.44);">注意，</font>**** MySQL的InnoDB 存储引擎就是使用MVCC来支持事务操作的。**

# <font style="color:#ECAA04;">67.</font><font style="color:#ECAA04;">count(1)、count(*) 与 count(列名) 的区别</font>
**三者都是在SQL中用于计算行数的不同方式，存在以下区别：**

1. **<font style="color:#DF2A3F;">count(1)：</font>**
    - **count(1) 用于****<font style="color:rgba(251,11,138,0.44);">计算结果集</font>****中的****<font style="color:rgba(251,11,138,0.44);">行数</font>****，****<font style="color:rgba(251,11,138,0.44);">不考虑</font>****具体的列值，这种方式****<font style="color:rgba(251,11,138,0.44);">通常是最快的</font>****，因为它只需要统计行数。**
2. **<font style="color:#DF2A3F;">count(*)：</font>**
    - **count(*) 也用于计算结果集中的行数，****<font style="color:rgba(251,11,138,0.44);">与 count(1) 类似</font>****，它也****<font style="color:rgba(251,11,138,0.44);">不需要</font>****考虑特定列的值，但在某些数据库系统中，它可能****<font style="color:rgba(251,11,138,0.44);">稍微慢一些</font>****，因为在执行时****<font style="color:rgba(251,11,138,0.44);">会考虑对表的全面扫描</font>****。**
    - **然而，现代数据库优化器通常会将 count(*) 优化为 count(1)。**
3. **<font style="color:#DF2A3F;">count(列名)：</font>**
    - **count(列名) 用于****<font style="color:rgba(251,11,138,0.44);">计算特定列中非NULL值的行数</font>****，而不是结果集的总行数。**

# <font style="color:#ECAA04;">68. 为什么需要数据库连接池</font>
**数据库连接池是一种****<font style="color:rgba(251,11,138,0.44);">用于缓存和重复使用数据库连接</font>****的技术，****<font style="color:rgba(251,11,138,0.44);">以减少</font>****资源消耗和提高应用性能**

**<font style="color:rgba(251,11,138,0.44);">每次新建</font>****数据库****<font style="color:rgba(251,11,138,0.44);">连接</font>****都占用系统资源，特别是在****<font style="color:rgba(251,11,138,0.44);">并发用户较多</font>****的情况下会****<font style="color:rgba(251,11,138,0.44);">导致系统崩溃</font>****或性能下降**

**使用****<font style="color:rgba(251,11,138,0.44);">连接池</font>****可以****<font style="color:rgba(251,11,138,0.44);">预先创建一些连接</font>****，并在需要时****<font style="color:rgba(251,11,138,0.44);">重复利用</font>****，****<font style="color:rgba(251,11,138,0.44);">避免了</font>****频繁创建和关闭连接的开销，****<font style="color:rgba(251,11,138,0.44);">提高了</font>****应用程序的性能和可伸缩性**

**<font style="color:rgba(251,11,138,0.44);">此外，</font>****连接池还能灵活控制并发连接数量，****<font style="color:rgba(251,11,138,0.44);">避免</font>****数据库负载过高。****<font style="color:rgba(251,11,138,0.44);">通过调整</font>****连接池大小、等待队列长度和超时时间等****<font style="color:rgba(251,11,138,0.44);">参数</font>****，可以****<font style="color:rgba(251,11,138,0.44);">有效控制</font>****并发连接数，提高系统的稳定性**

# <font style="color:#ECAA04;">MySQL有哪几张权限表？</font>
**在 MySQL 数据库中，与权限相关的表如下：**

+ **<font style="color:rgb(255, 0, 1);">mysql.user：</font>****<font style="color:rgb(0, 0, 0);">存储所有</font>****<font style="color:rgba(251,11,138,0.44);">用户账号</font>****<font style="color:rgb(0, 0, 0);">的权限信息。</font>**
+ **<font style="color:rgb(255, 0, 1);">mysql.db：</font>****<font style="color:rgb(0, 0, 0);">记录用户对</font>****<font style="color:rgba(251,11,138,0.44);">数据库</font>****<font style="color:rgb(0, 0, 0);">的权限信息。</font>**
+ **<font style="color:rgb(255, 0, 1);">mysql.tables_priv：</font>****<font style="color:rgb(0, 0, 0);">记录用户对</font>****<font style="color:rgba(251,11,138,0.44);">表级别</font>****<font style="color:rgb(0, 0, 0);">的权限信息。</font>**
+ **<font style="color:rgb(255, 0, 1);">mysql.columns_priv：</font>****<font style="color:rgb(0, 0, 0);">记录用户对</font>****<font style="color:rgba(251,11,138,0.44);">列级别</font>****<font style="color:rgb(0, 0, 0);">的权限信息。</font>**
+ **<font style="color:rgb(255, 0, 1);">mysql.procs_priv：</font>****<font style="color:rgb(0, 0, 0);">记录用户对</font>****<font style="color:rgba(251,11,138,0.44);">存储过程和函数</font>****<font style="color:rgb(0, 0, 0);">的权限信息。</font>**

**这些表存储了 MySQL 数据库中各个用户的权限信息，通过操作这些表可以管理和控制用户的权限。**

****

****

****

# <font style="color:#ECAA04;">MySQL的binlog有几种录入格式？</font>
**MySQL的binlog有三种录入格式：statement、row和mixed。**

+ **<font style="color:rgb(255, 0, 1);">statement</font>****<font style="color:rgb(0, 0, 0);"> 格式记录</font>****<font style="color:rgba(251,11,138,0.44);">SQL语句本身</font>****<font style="color:rgb(0, 0, 0);">，但无法完美记录复杂操作。</font>**
+ **<font style="color:rgb(255, 0, 1);">row</font>****<font style="color:rgb(0, 0, 0);"> 格式记录</font>****<font style="color:rgba(251,11,138,0.44);">每一行数据的变更</font>****<font style="color:rgb(0, 0, 0);">，适用于事务性场景，但会产生大量日志。</font>**
+ **<font style="color:rgb(255, 0, 1);">mixed</font>****<font style="color:rgb(0, 0, 0);"> 格式是</font>****<font style="color:rgba(251,11,138,0.44);">statement和row的混合使用</font>****<font style="color:rgb(0, 0, 0);">，根据实际情况自动选择记录方式。</font>**

# <font style="color:#ECAA04;">InnoDB引擎的4大特性</font>
1. **<font style="color:rgb(255, 0, 1);">事务支持：</font>****<font style="color:rgba(251,11,138,0.44);">支持ACID事务</font>****<font style="color:rgb(0, 0, 0);">，</font>****<font style="color:rgba(251,11,138,0.44);">确保</font>****<font style="color:rgb(0, 0, 0);">数据完整性和一致性。</font>**
2. **<font style="color:rgb(255, 0, 1);">行级锁定：</font>****<font style="color:rgb(0, 0, 0);">提供</font>****<font style="color:rgba(251,11,138,0.44);">更好的</font>****<font style="color:rgb(0, 0, 0);">并发性能，</font>****<font style="color:rgba(251,11,138,0.44);">允许</font>****<font style="color:rgb(0, 0, 0);">多个事务同时处理表中不同行。</font>**
3. **<font style="color:rgb(255, 0, 1);">外键约束：</font>****<font style="color:rgb(0, 0, 0);">支持</font>****<font style="color:rgba(251,11,138,0.44);">定义外键关系</font>****<font style="color:rgb(0, 0, 0);">，</font>****<font style="color:rgba(251,11,138,0.44);">维护</font>****<font style="color:rgb(0, 0, 0);">表之间的数据一致性。</font>**
4. **<font style="color:rgb(255, 0, 1);">数据完整性：</font>****<font style="color:rgb(0, 0, 0);">支持</font>****<font style="color:rgba(251,11,138,0.44);">各种约束条件</font>****<font style="color:rgb(0, 0, 0);">，</font>****<font style="color:rgba(251,11,138,0.44);">防止</font>****<font style="color:rgb(0, 0, 0);">无效或不一致的数据插入。</font>**

# <font style="color:#ECAA04;">索引的基本原理</font>
**索引是****<font style="color:rgba(251,11,138,0.44);">排好序</font>****的数据结构，****<font style="color:rgba(251,11,138,0.44);">用于</font>****提高查询性能。**

**BTree 索引是****<font style="color:rgba(251,11,138,0.44);">常见的</font>****索引类型，它****<font style="color:rgba(251,11,138,0.44);">通过平衡树</font>****结构存储和查找数据。**

**在查询时，数据库会使用****<font style="color:rgba(251,11,138,0.44);"> BTree</font>**** 索引来****<font style="color:rgba(251,11,138,0.44);">定位</font>****符合条件的****<font style="color:rgba(251,11,138,0.44);">数据行</font>****所在的页，并依次查找数据。**

**为了优化****<font style="color:rgba(251,11,138,0.44);">查询性能</font>****，需要****<font style="color:rgba(251,11,138,0.44);">根据具体</font>****的业务****<font style="color:rgba(251,11,138,0.44);">需求和数据</font>****特点，分析查询条件和数据量，****<font style="color:rgba(251,11,138,0.44);">选择合适的索引</font>****类型和建立方式。**

# <font style="color:#ECAA04;">索引算法有哪些？</font>
**常见的索引算法有B-Tree、Hash、Bitmap、Full-Text和R树。**

+ **<font style="color:#DF2A3F;">B-Tree</font>****适用于****<font style="color:rgba(251,11,138,0.44);">范围查询</font>****和****<font style="color:rgba(251,11,138,0.44);">精确查找</font>****。**
+ **<font style="color:#DF2A3F;">Hash</font>****适用于****<font style="color:rgba(251,11,138,0.44);">等值查询</font>****。**
+ **<font style="color:#DF2A3F;">Bitmap</font>****适合****<font style="color:rgba(251,11,138,0.44);">布尔</font>****或****<font style="color:rgba(251,11,138,0.44);">多值类型</font>****的列。**
+ **<font style="color:#DF2A3F;">Full-Text</font>****适用于****<font style="color:rgba(251,11,138,0.44);">文本类型</font>****的数据列。**
+ **<font style="color:#DF2A3F;">R树</font>****主要应用于****<font style="color:rgba(251,11,138,0.44);">空间数据</font>****处理。**

# <font style="color:#ECAA04;">隔离级别与锁的关系</font>
**隔离级别和锁****<font style="color:rgba(251,11,138,0.44);">密切相关</font>****，****<font style="color:rgba(251,11,138,0.44);">不同</font>****隔离级别****<font style="color:rgba(251,11,138,0.44);">对应不同</font>****的****<font style="color:rgba(251,11,138,0.44);">锁机制</font>****。**

**<font style="color:rgba(251,11,138,0.44);">低隔离</font>****级别需要更****<font style="color:rgba(251,11,138,0.44);">严格的锁</font>****来控制并发，****<font style="color:rgba(251,11,138,0.44);">高隔离</font>****级别可以使用较****<font style="color:rgba(251,11,138,0.44);">宽松的锁</font>****来优化性能。**

**<font style="color:rgba(251,11,138,0.44);">锁机制</font>****用于****<font style="color:rgba(251,11,138,0.44);">处理并发</font>****事务中的****<font style="color:rgba(251,11,138,0.44);">数据冲突</font>****。**

**隔离级别和锁机制****<font style="color:rgba(251,11,138,0.44);">共同确保</font>****事务的正确执行和****<font style="color:rgba(251,11,138,0.44);">高并发的</font>****数据库应用。**

# <font style="color:#ECAA04;">使用索引一定能提高性能吗？</font>
**<font style="color:#DF2A3F;">不一定</font>****。**

**<font style="color:rgba(251,11,138,0.44);">原因包括</font>****查询****<font style="color:rgba(251,11,138,0.44);">条件不符合</font>****索引、****<font style="color:rgba(251,11,138,0.44);">数据量过大</font>****需遍历大量数据页、**

**<font style="color:rgba(251,11,138,0.44);">索引冗余</font>****和维护开销、数据****<font style="color:rgba(251,11,138,0.44);">分布不均匀</font>****。**

**需根据****<font style="color:rgba(251,11,138,0.44);">具体需求</font>****和数据****<font style="color:rgba(251,11,138,0.44);">特点</font>****进行评估和选择，****<font style="color:rgba(251,11,138,0.44);">避免创建</font>****过多冗余索引，**

**<font style="color:rgba(251,11,138,0.44);">确保查询</font>****条件和索引匹配，并进行****<font style="color:rgba(251,11,138,0.44);">适当优化</font>****措施，才能真正****<font style="color:rgba(251,11,138,0.44);">提高</font>****查询性能。**

# <font style="color:#ECAA04;">为什么要使用视图？什么是视图？</font>
**视图是****<font style="color:rgba(251,11,138,0.44);">虚拟表</font>****，由一个或多个****<font style="color:rgba(251,11,138,0.44);">基本表</font>****的查询结果****<font style="color:rgba(251,11,138,0.44);">组成。</font>**

**通过视图，可以将****<font style="color:rgba(251,11,138,0.44);">复杂的查询</font>****操作****<font style="color:rgba(251,11,138,0.44);">抽象为</font>****简单的视图查询，对于频繁需要执行的复杂查询，****<font style="color:rgba(251,11,138,0.44);">只需调用视图</font>****即可，****<font style="color:rgba(251,11,138,0.44);">提高了</font>****查询的方便性和效率。**

**同时，视图还****<font style="color:rgba(251,11,138,0.44);">能够限制</font>****用户只能访问特定的数据列，并****<font style="color:rgba(251,11,138,0.44);">隐藏敏感信息</font>****，****<font style="color:rgba(251,11,138,0.44);">保护了</font>****数据的安全性和隐私。**

# <font style="color:#ECAA04;">什么是游标？</font>
**游标是一种****<font style="color:rgba(251,11,138,0.44);">遍历关系型数据库结果集</font>****的机制，****<font style="color:rgba(251,11,138,0.44);">提供</font>****逐条处理或操作记录的方式。它可以****<font style="color:rgba(251,11,138,0.44);">按照指定的顺序</font>****逐行遍历结果集，****<font style="color:rgba(251,11,138,0.44);">并提供</font>****对当前行进行操作的方法。**

**游标分为****<font style="color:rgba(251,11,138,0.44);">静态游标</font>****和****<font style="color:rgba(251,11,138,0.44);">动态游标</font>****，****<font style="color:rgba(251,11,138,0.44);">前者将</font>****所有记录读入客户端结果集，****<font style="color:rgba(251,11,138,0.44);">后者只</font>****在处理过程中读取****<font style="color:rgba(251,11,138,0.44);">部分记录</font>****，需要时再向数据库查询。**

**游标可以****<font style="color:rgba(251,11,138,0.44);">用于处理</font>****较小规模数据表的结果集，****<font style="color:rgba(251,11,138,0.44);">有效地</font>****实现对数据的逐行处理和操作。**

# <font style="color:#ECAA04;">什么是存储过程？ </font>
**存储过程是封装在数据库中****<font style="color:rgba(251,11,138,0.44);">可重复执行的程序单元</font>****，类似于程序中的函数或子程序。它可以****<font style="color:rgba(251,11,138,0.44);">接受输入参数</font>****并****<font style="color:rgba(251,11,138,0.44);">返回数据集</font>****或标量值，也可以在内部进行业务逻辑处理。**

**存储过程的****<font style="color:#DF2A3F;">优点</font>****包括****<font style="color:rgba(251,11,138,0.44);">提高</font>****性能、可维护性和安全性，****<font style="color:rgba(251,11,138,0.44);">减少</font>****网络传输数据量；****<font style="color:#DF2A3F;">缺点</font>****则包括****<font style="color:rgba(251,11,138,0.44);">调试困难</font>****、产生****<font style="color:rgba(251,11,138,0.44);">代码膨胀</font>****和****<font style="color:rgba(251,11,138,0.44);">不易移植</font>****等问题。**

**在应用中，需要根据具体需求综合考虑是否使用存储过程。**

# <font style="color:#ECAA04;">什么是触发器？ </font>
**触发器是数据库中的对象，与表相关联，在数据操作时****<font style="color:rgba(251,11,138,0.44);">自动触发</font>****动作。****<font style="color:#DF2A3F;">使用场景</font>****包括****<font style="color:rgba(251,11,138,0.44);">确保数据完整性和一致性</font>****、数据同步和复制、日志记录和审计、****<font style="color:rgba(251,11,138,0.44);">处理</font>****复杂业务逻辑、数据变化通知等。**

**日常使用中****<font style="color:rgba(251,11,138,0.44);">需谨慎使用</font>****触发器，过多或复杂会影响数据库性能和可维护性，****<font style="color:rgba(251,11,138,0.44);">应考虑业务需求</font>****、数据操作频率和数据库性能，****<font style="color:rgba(251,11,138,0.44);">合理</font>****选择和配置触发器，****<font style="color:rgba(251,11,138,0.44);">避免</font>****循环调用和死锁问题，****<font style="color:rgba(251,11,138,0.44);">确保</font>****数据库稳定可靠。**

# <font style="color:#ECAA04;">MySQL中都有哪些触发器？</font>
**MySQL中支持三种类型的触发器：**

+ **<font style="color:#DF2A3F;">BEFORE触发器：</font>****在数据插入、更新或删除****<font style="color:rgba(251,11,138,0.44);">之前触发</font>****，可以****<font style="color:rgba(251,11,138,0.44);">用于检查数据</font>****的有效性、设置默认值等操作。**
+ **<font style="color:#DF2A3F;">AFTER触发器：</font>****在数据插入、更新或删除****<font style="color:rgba(251,11,138,0.44);">之后触发</font>****，****<font style="color:rgba(251,11,138,0.44);">可以用于记录</font>****日志、更新其他表中的数据等操作。**
+ **<font style="color:#DF2A3F;">INSTEAD OF触发器：</font>****<font style="color:rgba(251,11,138,0.44);">仅适用于视图</font>****，可以在对视图进行插入、更新或删除操作时触发，可以****<font style="color:rgba(251,11,138,0.44);">用于实现视图</font>****的可写功能。**

**触发器还可以根据****<font style="color:rgba(251,11,138,0.44);">触发事件类型分为</font>****INSERT、UPDATE和DELETE触发器。**

**除了类型和事件，MySQL触发器还有一些其他属性，如触发器的名称、所属表、触发时机、触发条件、触发器的语句等。**

# <font style="color:#ECAA04;">什么是超键、候选键、主键、外键？ </font>
**在关系型数据库中，四者是用于****<font style="color:#DF2A3F;">定义和管理数据表</font>****之间关系的重要概念。**

**<font style="color:#DF2A3F;">超键：</font>****能够****<font style="color:rgba(251,11,138,0.44);">唯一标识一个元组</font>****的属性集合。**

**<font style="color:#DF2A3F;">候选键：</font>****<font style="color:rgba(251,11,138,0.44);">最小</font>****的超键。**

**<font style="color:#DF2A3F;">主键：</font>****用来****<font style="color:rgba(251,11,138,0.44);">唯一标识每个元组</font>****的属性或属性组。**

**<font style="color:#DF2A3F;">外键：</font>****用来****<font style="color:rgba(251,11,138,0.44);">建立两个关系</font>****之间的联系。**

# <font style="color:#ECAA04;">SQL 约束有哪几种？ </font><font style="color:#DF2A3F;"></font>
**SQL 约束有以下几种：**

+ **<font style="color:#DF2A3F;">主键约束：</font>****用于****<font style="color:rgba(251,11,138,0.44);">定义一个或多个</font>****列作为主键，确保每行数据的唯一性和非空性。**
+ **<font style="color:#DF2A3F;">唯一约束：</font>****用于****<font style="color:rgba(251,11,138,0.44);">确保一个或多个列</font>****的取值在表中是****<font style="color:rgba(251,11,138,0.44);">唯一的</font>****，****<font style="color:rgba(251,11,138,0.44);">不允许重复</font>****。**
+ **<font style="color:#DF2A3F;">非空约束：</font>****用于确保一个或多个列****<font style="color:rgba(251,11,138,0.44);">不允许为空值</font>****，要求必须有值。**
+ **<font style="color:#DF2A3F;">外键约束：</font>****用于建立表与表之间的关系，****<font style="color:rgba(251,11,138,0.44);">确保一个表</font>****的列值与另一个表的主键或****<font style="color:rgba(251,11,138,0.44);">唯一键值相匹配</font>****。**
+ **<font style="color:#DF2A3F;">检查约束：</font>****用于****<font style="color:rgba(251,11,138,0.44);">定义一个列或多个</font>****列的取值****<font style="color:rgba(251,11,138,0.44);">必须符合指定的条件</font>****或表达式**

**这些约束可以保证数据的完整性和一致性，提供了对数据库中数据进行有效限制和验证的功能。**

# <font style="color:#ECAA04;">MySQL有哪些关联查询？ </font>
**在 MySQL 中，常见的关联查询如下：**

+ **<font style="color:#DF2A3F;">内连接：</font>****内连接****<font style="color:rgba(251,11,138,0.44);">返回两个表</font>****中满足****<font style="color:rgba(251,11,138,0.44);">连接条件的匹配行</font>****。**
+ **<font style="color:#DF2A3F;">左连接：</font>****左连接****<font style="color:rgba(251,11,138,0.44);">返回左表</font>****中的所有行，****<font style="color:rgba(251,11,138,0.44);">以及右表</font>****中与左表****<font style="color:rgba(251,11,138,0.44);">匹配的行</font>**
+ **<font style="color:#DF2A3F;">右连接：</font>****右连接****<font style="color:rgba(251,11,138,0.44);">返回右表</font>****中的所有行，****<font style="color:rgba(251,11,138,0.44);">以及左表</font>****中与右表****<font style="color:rgba(251,11,138,0.44);">匹配的行</font>**
+ **<font style="color:#DF2A3F;">全连接：</font>****全连接****<font style="color:rgba(251,11,138,0.44);">返回两个表</font>****中的****<font style="color:rgba(251,11,138,0.44);">所有行</font>****，****<font style="color:rgba(251,11,138,0.44);">无论是否</font>****存在****<font style="color:rgba(251,11,138,0.44);">匹配</font>****的数据**
+ **<font style="color:#DF2A3F;">自连接：</font>****自连接是指将同一个表作为两个不同的表来进行连接操作**
+ **<font style="color:#DF2A3F;">交叉连接：</font>****交叉连接****<font style="color:rgba(251,11,138,0.44);">返回两个表</font>****中****<font style="color:rgba(251,11,138,0.44);">所有可能</font>****的组合，即笛卡尔积。**

# <font style="color:#ECAA04;">什么是子查询 </font>
**子查询是指在****<font style="color:#DF2A3F;">一个 SQL</font>**** 查询语句中****<font style="color:#DF2A3F;">嵌套</font>****了****<font style="color:#DF2A3F;">另一个</font>****完整的****<font style="color:#DF2A3F;"> SQL</font>**** 查询语句。**

**<font style="color:rgba(251,11,138,0.44);">子查询</font>****可以用来****<font style="color:rgba(251,11,138,0.44);">获取某些条件下</font>****的特定****<font style="color:rgba(251,11,138,0.44);">结果集</font>****，这个结果集可以作为外层查询语句的一部分进行处理。**

**子查询****<font style="color:rgba(251,11,138,0.44);">通常出现在</font>**** WHERE 子句、FROM 子句或SELECT 子句中，它可以****<font style="color:rgba(251,11,138,0.44);">返回单个值</font>****、****<font style="color:rgba(251,11,138,0.44);">一列值</font>****或****<font style="color:rgba(251,11,138,0.44);">多列值</font>****。**

**子查询可以使用****<font style="color:rgba(251,11,138,0.44);">比较运算符</font>****（如 =、>、<、<>等）和****<font style="color:rgba(251,11,138,0.44);">逻辑运算符</font>****（如 AND、OR、NOT）来筛选数据。**

# <font style="color:#ECAA04;">子查询的三种情况 </font>
**子查询可以分为以下三种情况：**

+ **<font style="color:#DF2A3F;">标量子查询：</font>****标量子查询****<font style="color:rgba(251,11,138,0.44);">返回单个值</font>****，通常****<font style="color:rgba(251,11,138,0.44);">用于</font>****<font style="color:#000000;">比</font>****较运算符中的条件判断。**
+ **<font style="color:#DF2A3F;">列子查询：</font>****列子查询****<font style="color:rgba(251,11,138,0.44);">返回一列值</font>****，通常****<font style="color:rgba(251,11,138,0.44);">用于 </font>****IN 或 NOT IN 子句中的条件判断。**
+ **<font style="color:#DF2A3F;">表子查询：</font>****表子查询****<font style="color:rgba(251,11,138,0.44);">返回多列值</font>****，可以****<font style="color:rgba(251,11,138,0.44);">作为</font>****外层查询语句的一部分进行处理。**

# <font style="color:#ECAA04;">MySQL 中 in 和 exists 区别 </font>
**在 MySQL 中，IN 和 EXISTS 是用于子查询中的条件运算符，它们有以下区别：**

+ **<font style="color:#DF2A3F;">IN 运算符：</font>****用于****<font style="color:rgba(251,11,138,0.44);">检查</font>****一个****<font style="color:rgba(251,11,138,0.44);">值是否存在</font>****于子查询返回的结果集中。它将比较左侧的表达式与子查询的结果，并返回匹配的行。如果****<font style="color:rgba(251,11,138,0.44);">子查询</font>****返回的****<font style="color:rgba(251,11,138,0.44);">结果集</font>****中****<font style="color:rgba(251,11,138,0.44);">包含任何</font>****与左侧表达式****<font style="color:rgba(251,11,138,0.44);">匹配的值</font>****，则条件为真。**
+ **<font style="color:#DF2A3F;">EXISTS 运算符：</font>****用于****<font style="color:rgba(251,11,138,0.44);">检查子查询是否返回了</font>****至少一行****<font style="color:rgba(251,11,138,0.44);">结果</font>****。它只****<font style="color:rgba(251,11,138,0.44);">关心</font>****子查询是否返回了****<font style="color:rgba(251,11,138,0.44);">结果</font>****，而****<font style="color:rgba(251,11,138,0.44);">不关心</font>****具体的****<font style="color:rgba(251,11,138,0.44);">返回值</font>****是什么。如果子查询返回了至少一行结果，则条件为真。**

# <font style="color:#ECAA04;">VARCHAR 与 CHAR 的区别 </font>
**VARCHAR 和 CHAR 是 MySQL 中两种字符数据类型。**

**两者区别如下：**

+ **<font style="color:#DF2A3F;">存储方式：</font>****<font style="color:rgba(251,11,138,0.44);">CHAR</font>**** 是****<font style="color:rgba(251,11,138,0.44);">定长存储</font>****，占用固定空间；****<font style="color:#117CEE;">VARCHAR</font>**** 是****<font style="color:#117CEE;">变长存储</font>****，只占用实际需要的空间。**
+ **<font style="color:#DF2A3F;">存储效率：</font>****<font style="color:rgba(251,11,138,0.44);">CHAR</font>**** 存储****<font style="color:rgba(251,11,138,0.44);">效率高</font>****，访问和处理速度快；****<font style="color:#117CEE;">VARCHAR</font>**** 存储****<font style="color:#117CEE;">效率相对较低</font>****。**
+ **<font style="color:#DF2A3F;">索引效率：</font>****<font style="color:rgba(251,11,138,0.44);">CHAR</font>**** 索引****<font style="color:rgba(251,11,138,0.44);">效率高</font>****，使用固定大小索引；****<font style="color:#117CEE;">VARCHAR</font>**** 需要****<font style="color:#117CEE;">动态计算</font>****长度，使用变长索引。**
+ **<font style="color:#DF2A3F;">适用场景：</font>****<font style="color:rgba(251,11,138,0.44);">CHAR</font>**** 适用于****<font style="color:rgba(251,11,138,0.44);">长度固定</font>****的字符串；****<font style="color:#117CEE;">VARCHAR</font>**** 适用于****<font style="color:#117CEE;">长度可变</font>****的字符串。**

# <font style="color:#ECAA04;">VARCHAR(50)中50的涵义 </font>
**在 MySQL 中，VARCHAR(50)中的50****<font style="color:rgba(251,11,138,0.44);">表示</font>****该字段可以****<font style="color:rgba(251,11,138,0.44);">存储</font>****的****<font style="color:rgba(251,11,138,0.44);">最大字符数</font>****为50个。简单来说，该字段****<font style="color:rgba(251,11,138,0.44);">最多</font>****可以容纳50个字符，如果****<font style="color:rgba(251,11,138,0.44);">超过了</font>****50个字符，则会****<font style="color:rgba(251,11,138,0.44);">被截断</font>****。**

**需要注意的是，****<font style="color:rgba(251,11,138,0.44);">VARCHAR</font>**** 类型的****<font style="color:rgba(251,11,138,0.44);">实际存储</font>****空间****<font style="color:rgba(251,11,138,0.44);">取决于</font>****存储的****<font style="color:rgba(251,11,138,0.44);">数据长度</font>****，而不是定义的最大长度。例如，如果一个 ****<font style="color:rgba(251,11,138,0.44);">VARCHAR</font>****(50) 字段****<font style="color:rgba(251,11,138,0.44);">存储</font>****了****<font style="color:rgba(251,11,138,0.44);">10个字符</font>****，则它****<font style="color:rgba(251,11,138,0.44);">只</font>****会****<font style="color:rgba(251,11,138,0.44);">占用10个字符</font>****的存储空间，而****<font style="color:rgba(251,11,138,0.44);">不是50个</font>****字符的存储空间。**

# <font style="color:#ECAA04;">drop、delete与truncate的区别 </font>
**在 MySQL 中，DROP、DELETE 和 TRUNCATE 是三个不同的操作，它们有以下区别：**

+ **<font style="color:#DF2A3F;">DROP：</font>****DROP 用于****<font style="color:rgba(251,11,138,0.44);">删除整个表</font>****（包括表结构和数据）。执行后，表将被完全删除，****<font style="color:rgba(251,11,138,0.44);">无法恢复</font>****。**
+ **<font style="color:#DF2A3F;">DELETE：</font>****DELETE 用于****<font style="color:rgba(251,11,138,0.44);">删除</font>****表中的****<font style="color:rgba(251,11,138,0.44);">一部分或全部数据</font>****，****<font style="color:rgba(251,11,138,0.44);">保留</font>****表结构。可以使用 WHERE 子句指定删除的条件。执行后，被删除的数据可以通过****<font style="color:rgba(251,11,138,0.44);">事务回滚或备份进行恢复</font>****。**
+ **<font style="color:#DF2A3F;">TRUNCATE：</font>****TRUNCATE 用于****<font style="color:rgba(251,11,138,0.44);">删除表中的全部数据</font>****，保留表结构。TRUNCATE 操作比 DELETE 更快，因为它是通过****<font style="color:rgba(251,11,138,0.44);">直接删除</font>****表中的****<font style="color:rgba(251,11,138,0.44);">数据页</font>****来完成的，而不是逐行删除。执行后，被删除的数据****<font style="color:rgba(251,11,138,0.44);">无法</font>****通过事务回滚或备份****<font style="color:rgba(251,11,138,0.44);">进行恢复</font>****。**

# <font style="color:#ECAA04;">UNION与UNION ALL的区别？ </font>
**UNION和UNION ALL是SQL中的两个****<font style="color:rgba(251,11,138,0.44);">关键词</font>****，用于合并多个SELECT语句的结果集。它们的****<font style="color:rgba(251,11,138,0.44);">主要区别</font>****在于****<font style="color:rgba(251,11,138,0.44);">处理重复行的方式</font>****。**

+ **<font style="color:#DF2A3F;">UNION：</font>****UNION操作符用于合并多个SELECT语句的结果集，并****<font style="color:rgba(251,11,138,0.44);">自动去除重复的行</font>****。**
+ **<font style="color:#DF2A3F;">UNION ALL：</font>****UNION ALL操作符也用于合并多个SELECT语句的结果集，但****<font style="color:rgba(251,11,138,0.44);">不会去除重复的行</font>****。**

# <font style="color:#ECAA04;">如何定位慢 SQL</font>
**要定位慢SQL，可以按照以下步骤进行操作：**

+ **<font style="color:#DF2A3F;">监控数据库性能：</font>****使用****<font style="color:rgba(251,11,138,0.44);">性能监控工具</font>****或内置的****<font style="color:rgba(251,11,138,0.44);">系统监视器</font>****来了解数据库的整体性能。**
+ **<font style="color:#DF2A3F;">分析查询日志：</font>****查询日志可以记录数据库所有执行的SQL语句，在日志中搜索****<font style="color:rgba(251,11,138,0.44);">执行时间较长</font>****的****<font style="color:rgba(251,11,138,0.44);">SQL语句</font>****。**
+ **<font style="color:#DF2A3F;">使用性能分析工具：</font>****性能分析工具可以帮助我们****<font style="color:rgba(251,11,138,0.44);">深入理解</font>****慢SQL的****<font style="color:rgba(251,11,138,0.44);">执行过程</font>****。**
+ **<font style="color:#DF2A3F;">观察数据库指标：</font>****<font style="color:rgba(251,11,138,0.44);">观察数据库的性能指标</font>****，如CPU利用率、内存利用率、磁盘IO等，来了解数据库的负载情况。**

# <font style="color:#ECAA04;">如何优化慢 SQL语句</font>
**优化慢SQL，一般有以下多种方式：**

1. **<font style="color:rgba(251,11,138,0.44);">分析执行计划</font>****，避免全表扫描、索引未使用等耗时操作。**
2. **创建****<font style="color:rgba(251,11,138,0.44);">合适的索引</font>****，提高查询效率。**
3. **重写和****<font style="color:rgba(251,11,138,0.44);">简化复杂SQL语句</font>****，如避免使用SELECT *。**
4. **使用****<font style="color:rgba(251,11,138,0.44);">优化的分页</font>****技术，减少IO操作。**
5. **使用连接查询（JOIN）****<font style="color:rgba(251,11,138,0.44);">替代嵌套</font>****查询。**
6. **缓存查询结果，减少数据库访问。**
7. **<font style="color:rgba(251,11,138,0.44);">定期维护</font>****数据库，如重建索引、更新统计信息。**
8. **<font style="color:rgba(251,11,138,0.44);">调整数据库参数</font>****，如缓冲区大小、并发连接数等**

# <font style="color:#ECAA04;">索引失效场景</font>
**以下几种场景会出现索引失效：**

+ **使用了****<font style="color:rgba(251,11,138,0.44);">函数、操作符或表达式</font>****时。**
+ **列****<font style="color:rgba(251,11,138,0.44);">类型不匹配</font>****或隐式类型转换时。**
+ **列值****<font style="color:rgba(251,11,138,0.44);">范围过大</font>****或统计信息****<font style="color:rgba(251,11,138,0.44);">不准确</font>****时。**
+ **多表连接时****<font style="color:rgba(251,11,138,0.44);">连接条件不正确</font>****或连接的列没有索引时。**

# <font style="color:#ECAA04;">SQL的执行过程？</font>
**SQL是关系型数据库管理系统的标准语言，其执行过程包括以下几个步骤：**

+ **<font style="color:#DF2A3F;">词法分析：</font>****将SQL语句****<font style="color:rgba(251,11,138,0.44);">按照规则分解</font>****成单词、符号等组成的记号流，其中包括关键字、表名、列名、运算符等。**
+ **<font style="color:#DF2A3F;">语法分析：</font>****根据SQL语法规则检查词法分析所生成的记号流是否满足语法要求，****<font style="color:rgba(251,11,138,0.44);">判断语句是否正确</font>****。**
+ **<font style="color:#DF2A3F;">查询优化：</font>****对于SELECT语句，系统会根据统计信息、索引等信息进行查询优化，****<font style="color:rgba(251,11,138,0.44);">选择最合适的查询方式</font>****和访问路径，以提高查询效率。**
+ **<font style="color:#DF2A3F;">执行计划生成：</font>****生成查询执行计划，确定如何访问表和索引，并选择执行操作的****<font style="color:rgba(251,11,138,0.44);">最佳顺序和方法</font>****。**
+ **<font style="color:#DF2A3F;">执行SQL语句：</font>****<font style="color:rgba(251,11,138,0.44);">按照执行计划执行SQL语句</font>****，包括读取、插入、更新或删除表中的数据等操作。**
+ **<font style="color:#DF2A3F;">返回结果：</font>****将执行结果返回给用户。**

# <font style="color:#ECAA04;">怎么优化大表数据查询</font>
**针对大表数据查询的优化策略有如下方式：**

1. **<font style="color:#DF2A3F;">索引优化：</font>****创建****<font style="color:rgba(251,11,138,0.44);">适当的索引</font>****以提高查询速度。**
2. **<font style="color:#DF2A3F;">使用合适的连接方式：</font>****选择****<font style="color:rgba(251,11,138,0.44);">适当的连接方式</font>****和连接条件，减少磁盘 I/O 。**
3. **<font style="color:#DF2A3F;">调整数据类型：</font>****选择****<font style="color:rgba(251,11,138,0.44);">合适的数据类型</font>****来存储数据，减少I/O操作。**
4. **<font style="color:#DF2A3F;">分页查询：</font>****使用LIMIT语句****<font style="color:rgba(251,11,138,0.44);">限制返回的行数</font>****，避免一次性返回全部结果集**
5. **<font style="color:#DF2A3F;">批量操作：</font>****使用****<font style="color:rgba(251,11,138,0.44);">批量处理</font>****的方式，减少数据库连接开销，提高效率。**
6. **<font style="color:#DF2A3F;">垂直分割与水平分割：</font>****将****<font style="color:rgba(251,11,138,0.44);">大表拆分成多个小表</font>****，提高查询效率。**
7. **<font style="color:#DF2A3F;">使用缓存技术：</font>****将查询****<font style="color:rgba(251,11,138,0.44);">结果缓存</font>****起来，减少对数据库的访问。**
8. **<font style="color:#DF2A3F;">数据归档和清理：</font>****及时进行****<font style="color:rgba(251,11,138,0.44);">归档和清理</font>****，减少查询范围，提高查询效率。**

# <font style="color:#ECAA04;">为什么要尽量设定一个主键？ </font>
**MySQL的数据存储是通过****<font style="color:#DF2A3F;">B+树数据结构</font>****存储在文件中的，这种数据结构也被称为聚簇索引。每个表都会有且只有一个聚簇索引，而聚簇索引的键选择方式有三种情况：**

1. **如果****<font style="color:rgba(251,11,138,0.44);">设置了主键</font>****，那么聚簇索引会****<font style="color:rgba(251,11,138,0.44);">以主键列来构建</font>****。**
2. **如果****<font style="color:rgba(251,11,138,0.44);">没有设置主键</font>****，但存在非空唯一的列，那么聚簇索引会****<font style="color:rgba(251,11,138,0.44);">以该列来构建</font>****索引。**
3. **如果****<font style="color:rgba(251,11,138,0.44);">表中不存在非空唯一的列</font>****，那么聚簇索引会以一个****<font style="color:rgba(251,11,138,0.44);">隐藏的主键列</font>****来构建索引。**

**设置主键的意义在于它****<font style="color:rgba(251,11,138,0.44);">不仅能保证</font>****数据的唯一性，****<font style="color:rgba(251,11,138,0.44);">还可以</font>****通过以主键构建聚簇索引来提高数据操作的效率。**

# <font style="color:#ECAA04;">为什么推荐使用自增ID？ </font>
**推荐****<font style="color:rgba(251,11,138,0.44);">使用自增ID</font>****作为主键的原因有以下几点：**

+ **<font style="color:#DF2A3F;">索引效率高：</font>****自增ID主键是一个****<font style="color:rgba(251,11,138,0.44);">递增的整数序列</font>****，可以****<font style="color:rgba(251,11,138,0.44);">有效地减少</font>****索引的碎片化，****<font style="color:rgba(251,11,138,0.44);">提高</font>****查询效率。在****<font style="color:rgba(251,11,138,0.44);">B+树索引结构</font>****中，相邻的ID值通常存储在相邻的磁盘页上，****<font style="color:rgba(251,11,138,0.44);">减少了</font>****随机IO的次数，提升了查询性能。**
+ **<font style="color:#DF2A3F;">存储空间效率高：</font>****<font style="color:rgba(251,11,138,0.44);">相对于UUID</font>****主键，自增ID主键只需****<font style="color:rgba(251,11,138,0.44);">占用较小的整数类型</font>****的存储空间，****<font style="color:rgba(251,11,138,0.44);">节省了</font>****存储资源。尤其在大规模数据量的情况下，节省的存储空间会更加显著。**
+ **<font style="color:#DF2A3F;">简化数据维护和分片操作：</font>****使用自增ID主键可以****<font style="color:rgba(251,11,138,0.44);">简化数据的维护</font>****和分片操作。相对于UUID主键，****<font style="color:rgba(251,11,138,0.44);">自增ID主键</font>****不需要考虑全局唯一性的生成算法，****<font style="color:rgba(251,11,138,0.44);">避免了</font>****复杂的业务逻辑处理，并且在数据库分片时，也****<font style="color:rgba(251,11,138,0.44);">更容易</font>****进行数据的拆分和合并操作。**

# <font style="color:#ECAA04;">字段为什么要求定义为NOT NULL？ </font>
**在数据库中定义字段为 NOT NULL，是因为它有以下几个好处：**

1. **<font style="color:#DF2A3F;">数据完整性：</font>****通过将字段定义为 NOT NULL，可以****<font style="color:rgba(251,11,138,0.44);">确保数据库</font>****中的每行记录都包含该字段的值。这****<font style="color:rgba(251,11,138,0.44);">有助于维护</font>****数据的****<font style="color:rgba(251,11,138,0.44);">完整性</font>****和****<font style="color:rgba(251,11,138,0.44);">一致性</font>****，避免出现****<font style="color:rgba(251,11,138,0.44);">数据不完整</font>****、丢失或错误的情况。**
2. **<font style="color:#DF2A3F;">查询性能：</font>****当使用****<font style="color:rgba(251,11,138,0.44);">包含 NULL 值</font>****的列进行查询时，数据库需要进行****<font style="color:rgba(251,11,138,0.44);">额外的处理</font>****来判断 NULL 值。这可能会导致****<font style="color:rgba(251,11,138,0.44);">查询速度变慢</font>****。如果将字段定义为 NOT NULL，则可以避免这种情况，提高查询性能。**
3. **<font style="color:#DF2A3F;">减少空间占用：</font>****<font style="color:rgba(251,11,138,0.44);">存储 NULL 值</font>****需要额外的空间。当数据表中包含许多 NULL 值时，它们会****<font style="color:rgba(251,11,138,0.44);">占用额外的存储空间</font>****。如果将字段定义为 NOT NULL，则可以减少空间占用。**

# <font style="color:#ECAA04;">MySQL 8.0 版本做了哪些优化</font>
**MySQL 8.0 ****<font style="color:#000000;">主要有如下几点优化</font>****：**

1. **JSON 支持更完善。**
2. **引入****<font style="color:rgba(251,11,138,0.44);">窗口函数</font>****和****<font style="color:rgba(251,11,138,0.44);">分析函数</font>****。**
3. **全局事务标识符****<font style="color:rgba(251,11,138,0.44);">简化复制拓扑结构</font>****。**
4. **默认****<font style="color:rgba(251,11,138,0.44);">支持加密连接</font>****，提供更多加密功能。**
5. **引入更****<font style="color:rgba(251,11,138,0.44);">精细的资源管理</font>****功能。**
6. **增加字符集和校对规则。**
7. **优化了查询性能。**

# <font style="color:#ECAA04;">为什么大厂不建议使用多表 JOIN</font>
**大厂不建议过度使用多表 JOIN 的原因主要有以下几点：**

1. **<font style="color:#DF2A3F;">性能问题：</font>****多表 JOIN 会****<font style="color:rgba(251,11,138,0.44);">导致数据库执行</font>****较为****<font style="color:rgba(251,11,138,0.44);">复杂的查询操作</font>****，特别是在表数据量大、索引不够完善或者查询条件复杂的情况下，容易导致****<font style="color:rgba(251,11,138,0.44);">性能下降</font>****，影响系统的响应速度。**
2. **<font style="color:#DF2A3F;">可维护性：</font>****过多的多表 JOIN 会使得 SQL 查询语句变得****<font style="color:rgba(251,11,138,0.44);">复杂且难以维护</font>****，****<font style="color:rgba(251,11,138,0.44);">增加了</font>****代码的复杂度和理解难度，****<font style="color:rgba(251,11,138,0.44);">降低了</font>****代码的可读性和可维护性。**
3. **<font style="color:#DF2A3F;">扩展性：</font>****当系统需要扩展新的功能或者进行数据库结构调整时，存在****<font style="color:rgba(251,11,138,0.44);">多个表关联的查询语句可能需要频繁地修改</font>****，增加了维护和扩展的成本。**

# <font style="color:#ECAA04;">为什么MySQL默认使用RR隔离级别</font>
**这是因为RR级别提供了****<font style="color:rgba(251,11,138,0.44);">较高的事务隔离性</font>****，可以****<font style="color:rgba(251,11,138,0.44);">避免</font>****脏读、不可重复读和幻读等****<font style="color:rgba(251,11,138,0.44);">并发访问问题</font>****。**

**在RR隔离级别下，事务在读取数据时会****<font style="color:rgba(251,11,138,0.44);">创建一个快照</font>****，并在事务结束前始终使用该快照来****<font style="color:rgba(251,11,138,0.44);">保证数据的一致性</font>****，从而****<font style="color:rgba(251,11,138,0.44);">避免了</font>****其他事务对数据的并发修改对当前事务的影响。**

**虽然RR提供了较高的隔离性，但也可能****<font style="color:rgba(251,11,138,0.44);">导致</font>****一些****<font style="color:rgba(251,11,138,0.44);">性能损失</font>****，因为它要求数据库在事务期间保持一致的快照视图，这可能****<font style="color:rgba(251,11,138,0.44);">会阻碍</font>****其他事务对数据的修改，****<font style="color:rgba(251,11,138,0.44);">增加了</font>****系统的并发控制负担。**

**但在特定情况下，用户也可以****<font style="color:rgba(251,11,138,0.44);">根据自己的需求来选择更低的隔离级别</font>****，以获得更好的性能表现，如RC（Read Committed）隔离级别。**

# <font style="color:#ECAA04;">当前读和快照读有什么区别</font>
**<font style="color:#DF2A3F;">当前读</font>****和****<font style="color:#DF2A3F;">快照读</font>****是关于数据库****<font style="color:#DF2A3F;">隔离级别</font>****的****<font style="color:#DF2A3F;">两种读取方式</font>****。**

**当前读是指在事务执行过程中，****<font style="color:rgba(251,11,138,0.44);">读取的数据是最新的</font>****，会受到并发事务的影响。**

**而快照读是在事务****<font style="color:rgba(251,11,138,0.44);">开始时确定需要读取的数据版本</font>****，接下来的读取都会使用这个版本的数据，不受其他事务影响。**

**<font style="color:#DF2A3F;">当前读</font>****通常用于****<font style="color:rgba(251,11,138,0.44);">可重复读</font>****和****<font style="color:rgba(251,11,138,0.44);">串行化</font>****隔离级别，****<font style="color:#DF2A3F;">而快照读</font>****通常用于****<font style="color:rgba(251,11,138,0.44);">读已提交</font>****和****<font style="color:rgba(251,11,138,0.44);">可重复读</font>****隔离级别。**

# <font style="color:#ECAA04;">什么是意向锁</font>
**意向锁是数据库管理系统中的****<font style="color:rgba(251,11,138,0.44);">一种锁定机制</font>****，用于****<font style="color:rgba(251,11,138,0.44);">协调事务对数据行的排他锁和共享锁请求</font>****。**

**意向锁分为两种类型：****<font style="color:#DF2A3F;">意向共享锁</font>****和****<font style="color:#DF2A3F;">意向排他锁</font>****。**

**当****<font style="color:rgba(251,11,138,0.44);">一个事务</font>****需要对某个数据行进行****<font style="color:rgba(251,11,138,0.44);">加锁时</font>****，****<font style="color:rgba(251,11,138,0.44);">会先尝试获取</font>****相应的****<font style="color:rgba(251,11,138,0.44);">意向锁</font>****，以表示接下来可能会对数据行进行共享锁或排他锁的申请。**

**通过使用****<font style="color:rgba(251,11,138,0.44);">意向锁</font>****，数据库系统可以****<font style="color:rgba(251,11,138,0.44);">更高效地判断</font>****是否有其他事务对数据行已经持有了排他锁或共享锁，从而****<font style="color:rgba(251,11,138,0.44);">避免不必要的锁竞争和冲突</font>****。**

**这种机制可以****<font style="color:rgba(251,11,138,0.44);">提高并发</font>****访问效率，****<font style="color:rgba(251,11,138,0.44);">降低锁冲突</font>****的概率，从而减少了事务之间的阻塞情况，提升了数据库系统的整体性能。**

# <font style="color:#ECAA04;">MySQL的主键一定是自增的吗</font>
**<font style="color:#DF2A3F;">主键并不一定是自增的</font>****。**

**虽然自增主键是一种常见的主键类型，但在****<font style="color:rgba(251,11,138,0.44);">实际数据库</font>****操作中，我们经常会遇到数据****<font style="color:rgba(251,11,138,0.44);">插入失败</font>****、****<font style="color:rgba(251,11,138,0.44);">数据删除</font>****、****<font style="color:rgba(251,11,138,0.44);">事务回滚</font>****、****<font style="color:rgba(251,11,138,0.44);">数据订正</font>****等情况，这些情况都可能****<font style="color:rgba(251,11,138,0.44);">导致自增字段的值</font>****出现****<font style="color:rgba(251,11,138,0.44);">间断或重复</font>****，打破了自增ID的连续性。**

**因此，主键可以是任何具有****<font style="color:rgba(251,11,138,0.44);">唯一性和非空性</font>****的字段，如整型、字符型等，并不一定要求是自增的。**

**选择主键类型取决于****<font style="color:rgba(251,11,138,0.44);">具体的业务需求和数据特点</font>****，对于不需要自动增长的场景，可以选择其他类型的主键来满足需求。**

# <font style="color:#ECAA04;">Binlog、Redolog和 Undolog 的区别</font>
**Binlog（****<font style="color:#DF2A3F;">二进制日志</font>****）、Redo log（****<font style="color:#DF2A3F;">重做日志</font>****）、 Undo log（****<font style="color:#DF2A3F;">回滚日志</font>****）它们是数据库中常见的日志类型。**

+ **<font style="color:#DF2A3F;">Binlog：</font>****用于****<font style="color:rgba(251,11,138,0.44);">备份与复制</font>****，记录了对数据进行更改的 SQL 语句或其他相关信息；**
+ **<font style="color:#DF2A3F;">Redo log：</font>****用于****<font style="color:rgba(251,11,138,0.44);">事务的持久性和数据库崩溃恢复</font>****，记录了数据库引擎对数据页的修改，确保事务提交后的修改可以被恢复；**
+ **<font style="color:#DF2A3F;">Undo log：</font>****用于****<font style="color:rgba(251,11,138,0.44);">事务的撤销和多版本并发控制</font>****，记录了事务的逆操作，用于事务回滚和历史版本数据读取。**

**三种日志相互配合，共同确保了数据库的一致性、持久性和并发控制。**

# <font style="color:#ECAA04;">数据库死锁如何解决</font>
**解决数据库死锁可以采取以下方法：**

1. **优化事务，****<font style="color:rgba(251,11,138,0.44);">缩短持锁时间</font>****，减少死锁风险。**
2. **确保事务顺序一致性，****<font style="color:rgba(251,11,138,0.44);">有助于减少死锁</font>****可能性。**
3. **减少锁粒度，尽量使用行级锁而非表级锁。**
4. **设置合理超时时间，****<font style="color:rgba(251,11,138,0.44);">通过超时回滚来解除死锁</font>****。**
5. **<font style="color:rgba(251,11,138,0.44);">监控死锁</font>****，及时发现并解决死锁问题。**
6. **实现死锁检测和重试机制，遇到****<font style="color:rgba(251,11,138,0.44);">死锁时自动重试</font>****事务。**

# <font style="color:#ECAA04;">order by 是怎么实现的</font>
**数据库中的"ORDER BY"实现****<font style="color:rgba(251,11,138,0.44);">涉及查询语句解析</font>****、****<font style="color:rgba(251,11,138,0.44);">记录检索</font>****和****<font style="color:rgba(251,11,138,0.44);">排序阶段</font>**

**数据库系统根据指定列****<font style="color:rgba(251,11,138,0.44);">使用排序算法</font>****（如快速排序）对记录****<font style="color:rgba(251,11,138,0.44);">进行排序</font>****，最后返回排序后的结果集。**

**为****<font style="color:rgba(251,11,138,0.44);">提高效率</font>****，数据库可能****<font style="color:rgba(251,11,138,0.44);">利用索引加速排序</font>****、在内存中执行排序以减少磁盘访问频率等策略。**

**<font style="color:rgba(251,11,138,0.44);">针对不同查询和数据量</font>****，数据库系统会根据优化器****<font style="color:rgba(251,11,138,0.44);">选择合适的</font>****排序方法，确保针对大规模数据的排序操作能够高效完成。**

# <font style="color:#ECAA04;">SQL中PK、UK、CK、FK、DF是什么意思</font>
**在SQL中，这些缩写代表了不同的约束类型：**

1. **<font style="color:#DF2A3F;">PK (Primary Key): </font>****<font style="color:rgba(251,11,138,0.44);">主键约束</font>****，用于唯一标识表中的每一行数据。主键的值****<font style="color:rgba(251,11,138,0.44);">不能重复</font>****，且****<font style="color:rgba(251,11,138,0.44);">不能为空</font>****。**
2. **<font style="color:#DF2A3F;">UK (Unique Key): </font>****<font style="color:rgba(251,11,138,0.44);">唯一约束</font>****，确保列中的****<font style="color:rgba(251,11,138,0.44);">数值是唯一的</font>****，但****<font style="color:rgba(251,11,138,0.44);">可以</font>****包含空值。**
3. **<font style="color:#DF2A3F;">CK (Check Constraint): </font>****<font style="color:rgba(251,11,138,0.44);">检查约束</font>****，用于确保列中的数据满足特定的条件，类似于对列****<font style="color:rgba(251,11,138,0.44);">添加额外的验证条件</font>****。**
4. **<font style="color:#DF2A3F;">FK (Foreign Key): </font>****<font style="color:rgba(251,11,138,0.44);">外键约束</font>****，用于在一个表中创建指向另一个表中主键的外键关系，****<font style="color:rgba(251,11,138,0.44);">确保引用的完整性</font>****。**
5. **<font style="color:#DF2A3F;">DF (Default Constraint):</font>**** ****<font style="color:rgba(251,11,138,0.44);">默认约束</font>****，用于指定列的默认值。如果插入行时未提供值，将会使用默认值。**

# <font style="color:#ECAA04;">什么是 Spring 的 IOC</font>
**Spring的IOC（全称 Inversion of Control，控制反转），它是****<font style="color:#DF2A3F;">Spring框架</font>****的****<font style="color:#DF2A3F;">核心概念</font>****之一。它主要包括以下关键点：**

1. **<font style="color:rgba(251,11,138,0.44);">IOC的目的</font>****是将应用程序的****<font style="color:rgba(251,11,138,0.44);">控制权</font>****从应用程序代码中****<font style="color:rgba(251,11,138,0.44);">转移到</font>****框架或容器中。**
2. **IOC容器管理bean的****<font style="color:rgba(251,11,138,0.44);">生命周期</font>****和****<font style="color:rgba(251,11,138,0.44);">依赖注入</font>****。**
3. **开发者只需配置bean的依赖关系，IOC容器会根据配置创建对象并进行注入。**
4. **通过IOC实现****<font style="color:rgba(251,11,138,0.44);">松耦合</font>****、****<font style="color:rgba(251,11,138,0.44);">提高代码可维护性</font>****和可测试性。**
5. **Spring的IOC提供了一种****<font style="color:rgba(251,11,138,0.44);">灵活、易于管理和维护的组件</font>****组织方式。**

# <font style="color:#ECAA04;">什么是 Spring 的 AOP</font>
**Spring的AOP（也称为面向切面编程）是****<font style="color:#DF2A3F;">Spring框架的另一个核心概念</font>****，主要包括以下关键点：**

1. **AOP用于将****<font style="color:rgba(251,11,138,0.44);">横切关注点</font>****（如****<font style="color:rgba(251,11,138,0.44);">日志</font>****、****<font style="color:rgba(251,11,138,0.44);">事务处理</font>****）从应用程序的****<font style="color:rgba(251,11,138,0.44);">核心业务</font>****逻辑中****<font style="color:rgba(251,11,138,0.44);">分离出来</font>****。**
2. **AOP通过****<font style="color:rgba(251,11,138,0.44);">切面</font>****（Aspect）实现对横切关注点的****<font style="color:rgba(251,11,138,0.44);">模块化</font>****组织。**
3. **切面可以定义在****<font style="color:rgba(251,11,138,0.44);">哪些连接点</font>****（Join Point）上执行哪些通知（Advice），并可以****<font style="color:rgba(251,11,138,0.44);">使用切点</font>****（Pointcut）****<font style="color:rgba(251,11,138,0.44);">指定连接点</font>****。**
4. **Spring AOP****<font style="color:rgba(251,11,138,0.44);">支持多种类型</font>****的通知，包括前置通知、后置通知、环绕通知等。**
5. **AOP能够****<font style="color:rgba(251,11,138,0.44);">提高代码的重用性</font>****，****<font style="color:rgba(251,11,138,0.44);">降低</font>****系统耦合度，使得系统更易于维护和扩展。**

# <font style="color:#ECAA04;">Spring Bean 的初始化过程</font>
**S****pring容器在实例化Bean时，会经历以下初始化过程：**

1. **<font style="color:#DF2A3F;">实例化Bean：</font>****通过****<font style="color:rgba(251,11,138,0.44);">构造器</font>****或****<font style="color:rgba(251,11,138,0.44);">工厂方法</font>****创建Bean的实例。**
2. **<font style="color:#DF2A3F;">设置Bean的属性：</font>****Spring容器将****<font style="color:rgba(251,11,138,0.44);">根据配置文件</font>****或****<font style="color:rgba(251,11,138,0.44);">注解</font>****为Bean设置属性。**
3. **<font style="color:#DF2A3F;">实现Aware接口：</font>****如果Bean****<font style="color:rgba(251,11,138,0.44);">实现了Aware接口</font>****（如****<font style="color:rgba(251,11,138,0.44);">BeanNameAware</font>****、****<font style="color:rgba(251,11,138,0.44);">BeanFactoryAware</font>****等），Spring容器会调用相应的方法注入相关资源。**
4. **<font style="color:#DF2A3F;">调用BeanPostProcessor的前置处理方法：</font>****如果有注册的BeanPostProcessor，会在初始化前执行相应的****<font style="color:#262626;">前置处理方法</font>****。**
5. **<font style="color:#DF2A3F;">调用初始化方法：</font>****如果Bean****<font style="color:rgba(251,11,138,0.44);">配置了初始化方法</font>****（通过init-method属性或@PostConstruct注解），Spring容器会调用该方法进行初始化。**
6. **<font style="color:#DF2A3F;">实现InitializingBean接口：</font>****如果Bean****<font style="color:rgba(251,11,138,0.44);">实现了InitializingBean接口</font>****，Spring容器会调用其****<font style="color:#000000;">afterPropertiesSet()方法</font>****。**
7. **<font style="color:#DF2A3F;"> 调用BeanPostProcessor的后置处理方法：</font>****<font style="color:#000000;">如果有注册的BeanPostProcessor</font>****，会在****<font style="color:rgba(251,11,138,0.44);">初始化后执行</font>****相应的****<font style="color:rgba(251,11,138,0.44);">后置处理方法</font>****。**

# <font style="color:#ECAA04;">Spring 事务传播机制</font>
**Spring框架的事务传播机制是用来控制多个事务方法相互调用时事务如何传播的规则。在Spring中，可以****<font style="color:#DF2A3F;">通过@Transactional注解或编程式事务管理</font>****来配置事务传播行为。**

**下面是一些常见的事务传播行为：**

1. **<font style="color:#DF2A3F;">REQUIRED：</font>****<font style="color:#000000;">如果</font>****<font style="color:rgba(251,11,138,0.44);">存在</font>****事务，****<font style="color:#000000;">则</font>****<font style="color:rgba(251,11,138,0.44);">加入</font>****该事务；****<font style="color:#000000;">如果</font>****<font style="color:rgba(251,11,138,0.44);">没有</font>****事务，****<font style="color:#000000;">则</font>****<font style="color:rgba(251,11,138,0.44);">创建</font>****一个新的事务。**
2. **<font style="color:#DF2A3F;">SUPPORTS：</font>****如果****<font style="color:rgba(251,11,138,0.44);">存在</font>****事务，则****<font style="color:rgba(251,11,138,0.44);">加入</font>****该事务；如果****<font style="color:rgba(251,11,138,0.44);">没有</font>****事务，则****<font style="color:rgba(251,11,138,0.44);">以非事务的方式执行</font>**
3. **<font style="color:#DF2A3F;">MANDATORY：</font>****<font style="color:rgba(251,11,138,0.44);">必须在</font>****一个已有的****<font style="color:rgba(251,11,138,0.44);">事务中执行</font>****，否则抛出异常。**
4. **<font style="color:#DF2A3F;">REQUIRES_NEW：</font>****<font style="color:rgba(251,11,138,0.44);">创建一个新的事务</font>****，如果当前存在事务，则将当前事务挂起。**
5. **<font style="color:#DF2A3F;">NOT_SUPPORTED：</font>****<font style="color:rgba(251,11,138,0.44);">以非事务方式执行</font>****操作，如果存在事务，则将当前事务挂起。**
6. **<font style="color:#DF2A3F;">NEVER：</font>****<font style="color:#000000;">以非事务方式执行</font>****操作，如果当前存在事务，则抛出异常。**
7. **<font style="color:#DF2A3F;">NESTED：</font>****如果当前****<font style="color:rgba(251,11,138,0.44);">存在事务</font>****，则在****<font style="color:rgba(251,11,138,0.44);">嵌套事务内执行</font>****；如果当前没有事务，则表现类似于REQUIRED。**

# <font style="color:#ECAA04;">Autowired 和 Resource 的区别</font>
**@Autowired和@Resource都是****<font style="color:#DF2A3F;">用于依赖注入的注解</font>****，用于将其他组件或资源自动注入到目标对象中。它们在使用方式和功能上有一些区别：**

1. **<font style="color:#DF2A3F;">@Autowired：</font>**
+ **是****<font style="color:rgba(251,11,138,0.44);">Spring框架</font>****的注解，****<font style="color:rgba(251,11,138,0.44);">基于类型</font>****进行依赖注入。**
+ **默认按照类型进行匹配注入，如果存在****<font style="color:rgba(251,11,138,0.44);">多个匹配类型</font>****的Bean，****<font style="color:rgba(251,11,138,0.44);">则根据属性名称</font>****进行匹配。**
+ **可以****<font style="color:rgba(251,11,138,0.44);">用于构造器、字段、方法或者参数</font>****上。**
+ **支持通过@Qualifier注解指定具体的Bean名称进行注入。**
2. **<font style="color:#DF2A3F;">@Resource：</font>**
+ **是****<font style="color:rgba(251,11,138,0.44);">Java EE规范</font>****中定义的注解，在Java 6及以上版本中可用。**
+ **基于名称进行依赖注入，****<font style="color:rgba(251,11,138,0.44);">先按照名称</font>****查找，****<font style="color:rgba(251,11,138,0.44);">再按照类型</font>****匹配。**
+ **<font style="color:#000000;">默认按照属性名称</font>****进行查找，也可以通过name属性指定具体的Bean名称进行注入。**
+ **只能****<font style="color:rgba(251,11,138,0.44);">用于字段、setter方法或者参数</font>****上。**

# <font style="color:#ECAA04;">BeanFactory 和 FactroyBean 的区别</font>
**BeanFactory和FactoryBean是Spring框架中的两个不同的概念，它们有以下区别：**

1. **<font style="color:#DF2A3F;">BeanFactory：</font>**
+ **是****<font style="color:rgba(251,11,138,0.44);">Spring框架</font>****的核心****<font style="color:rgba(251,11,138,0.44);">接口</font>****之一，用于****<font style="color:rgba(251,11,138,0.44);">管理和获取</font>****Bean实例。**
+ **是一个****<font style="color:rgba(251,11,138,0.44);">容器</font>****，负责实例化、配置和管理Bean对象。**
+ **提供了一系列的方法用于****<font style="color:rgba(251,11,138,0.44);">获取Bean</font>****，如根据名称获取Bean、根据类型获取Bean等。**
+ **<font style="color:rgba(251,11,138,0.44);">可以延迟</font>****加载Bean实例，只在使用时才进行实例化。**
2. **<font style="color:#DF2A3F;">FactoryBean：</font>**
+ **是一个****<font style="color:rgba(251,11,138,0.44);">特殊的Bean</font>****，实现了FactoryBean接口。**
+ **用于****<font style="color:rgba(251,11,138,0.44);">自定义Bean的实例化逻辑</font>****，可以通过FactoryBean创建复杂的Bean实例。**
+ **FactoryBean的实现类可以****<font style="color:rgba(251,11,138,0.44);">定义自己的逻辑来创建和管理Bean对象</font>****，并将其作为一个普通Bean注册到Spring容器中。**
+ **在从容器中获取FactoryBean时，实际上获取到的是FactoryBean创建的对象，而不是FactoryBean本身。**

# <font style="color:#ECAA04;">Spring 用到了哪些设计模式</font>
1. **<font style="color:#DF2A3F;">单例模式：</font>****Spring默认使用****<font style="color:rgba(251,11,138,0.44);">单例模式来管理和创建Bean对象</font>****，确保在整个应用中只有一个实例存在。**
2. **<font style="color:#DF2A3F;">工厂模式：</font>****Spring使用****<font style="color:rgba(251,11,138,0.44);">工厂模式来创建和管理Bean实例</font>****，通过BeanFactory或ApplicationContext等容器来托管和管理Bean的生命周期。**
3. **<font style="color:#DF2A3F;">代理模式：</font>****Spring AOP 基于动态代理技术，****<font style="color:rgba(251,11,138,0.44);">通过代理对象对目标对象进行增强</font>****，实现横切关注点的模块化处理。**
4. **<font style="color:#DF2A3F;">观察者模式：</font>****Spring的****<font style="color:rgba(251,11,138,0.44);">事件驱动机制基于观察者模式</font>****，通过发布-订阅模型实现不同组件之间的解耦和通信。**
5. **<font style="color:#DF2A3F;">模板方法模式：</font>****Spring的JdbcTemplate等模板类****<font style="color:rgba(251,11,138,0.44);">使用了模板方法</font>****模式，将通用的业务逻辑****<font style="color:rgba(251,11,138,0.44);">封装在抽象类</font>****中，子类可以通过重写特定的方法来实现自己的逻辑。**
6. **<font style="color:#DF2A3F;">策略模式：</font>****Spring的****<font style="color:rgba(251,11,138,0.44);">事务管理中使用了</font>****策略模式，通过配置不同的事务管理策略来适应不同的事务需求。**
7. **<font style="color:#DF2A3F;">装饰器模式：</font>****Spring的****<font style="color:rgba(251,11,138,0.44);">装饰模式被应用在AOP</font>****中，通过动态代理和装饰器模式实现对目标对象的增强。**

# <font style="color:#ECAA04;">什么是 Spring 循环依赖</font>
**Spring循环依赖指的是在Spring容器中存在****<font style="color:rgba(251,11,138,0.44);">相互依赖的Bean对象</font>****，形成了一个循环的引用关系。简单来说，就是****<font style="color:rgba(251,11,138,0.44);">A依赖于B</font>****，同时****<font style="color:rgba(251,11,138,0.44);">B也依赖于A</font>****，这样就形成了一个循环的依赖。**![1700140919048-c3008ab0-0d29-464d-ae07-8f9c0693d202.png](./img/NRYZr_RWH4KAbUI_/1700140919048-c3008ab0-0d29-464d-ae07-8f9c0693d202-694532.png)

# <font style="color:#ECAA04;">Spring 事务失效原因</font>
**Spring事务失效通常有多种原因，以下是一些常见的导致Spring事务失效的原因：**

1. **<font style="color:#DF2A3F;">未正确配置事务管理器：</font>****在Spring中如果****<font style="color:rgba(251,11,138,0.44);">未正确配置</font>****事务管理器或者****<font style="color:rgba(251,11,138,0.44);">使用了不支持事务</font>****的事务管理器，会导致事务失效。**
2. **<font style="color:#DF2A3F;">未添加@Transactional注解或XML配置：</font>****在使用声明式事务时，****<font style="color:rgba(251,11,138,0.44);">未</font>****在需要事务支持的方法上****<font style="color:rgba(251,11,138,0.44);">添加@Transactional注解</font>****，或者****<font style="color:rgba(251,11,138,0.44);">未在XML配置中</font>****配置事务相关内容，都会导致事务失效。**
3. **<font style="color:#DF2A3F;">异常未被正确捕获和处理：</font>****在事务方法中，如果业务逻辑抛出****<font style="color:rgba(251,11,138,0.44);">异常未被正确捕获</font>****和处理，会导致事务失效，因为Spring****<font style="color:rgba(251,11,138,0.44);">默认只对受检查异常进行回滚</font>****，对于未受检查异常（RuntimeException及其子类）才会进行回滚。**
4. **<font style="color:#DF2A3F;">事务传播行为设置错误：</font>****如果在调用事务方法时，事务****<font style="color:rgba(251,11,138,0.44);">传播行为设置错误</font>****，可能会导致事务失效。**
5. **<font style="color:#DF2A3F;">方法调用问题：</font>****如果在同一个****<font style="color:rgba(251,11,138,0.44);">类中的方法直接调用</font>****，而不是通过代理对象调用，也可能导致事务失效，因为Spring的事务是通过动态代理实现的。**

# <font style="color:#ECAA04;">什么是 MVC</font>
**MVC是一种软件设计模式，用于将应用程序的不同方面进行分离，以提高代码的可维护性和可扩展性。**

**<font style="color:rgba(251,11,138,0.44);">MVC代表模型（Model）</font>****、****<font style="color:rgba(251,11,138,0.44);">视图（View）和控制器（Controller）</font>****，它们分别负责处理应用程序的数据、展示和用户交互。**

1. **<font style="color:#DF2A3F;">模型（Model）：</font>****模型表示****<font style="color:rgba(251,11,138,0.44);">应用程序的数据和业务逻辑</font>****。它负责处理数据的读取、写入、验证和处理，与数据库或其他数据源进行交互，以及执行业务规则和操作。**
2. **<font style="color:#DF2A3F;">视图（View）：</font>****视图负责****<font style="color:rgba(251,11,138,0.44);">展示模型中的数据</font>****给用户，并接收用户的输入。**
3. **<font style="color:#DF2A3F;">控制器（Controller）：</font>****控制器作为****<font style="color:rgba(251,11,138,0.44);">模型和视图之间的协调者</font>****，负责处理用户的请求、更新模型的数据，并选择适当的视图进行响应。**

****

****

****

****











**解决焦虑的唯一办法是学习！**

**路虽远，行则将至！事虽难，做则必成！**

****



> 更新: 2024-09-23 15:41:33  
> 原文: <https://www.yuque.com/tulingzhouyu/db22bv/kdhefpgyi2dbcn2b>