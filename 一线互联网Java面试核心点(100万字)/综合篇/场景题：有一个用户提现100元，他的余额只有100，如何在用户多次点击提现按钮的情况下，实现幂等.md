# 场景题：有一个用户提现 100 元，他的余额只有 100，如何在用户多次点击提现按钮的情况下，实现幂等

<font style="color:rgb(36, 41, 47);">在用户多次点击提现按钮的情况下，确保提现操作的幂等性，需综合采用以下方案：</font>

### <font style="color:rgb(36, 41, 47);">1. </font>**<font style="color:rgb(36, 41, 47);">生成唯一提现票据（ Token ）</font>**
+ **<font style="color:rgb(36, 41, 47);">实现逻辑</font>**<font style="color:rgb(36, 41, 47);">：用户进入提现页面时，后端生成一个唯一 Token（如 UUID ），存储到Redis并设置较短的有效期（如5秒），同时返回给前端。每次提现请求必须携带此 Token。</font>
+ **<font style="color:rgb(36, 41, 47);">作用</font>**<font style="color:rgb(36, 41, 47);">：防止用户短时间内重复提交请求，因为每次提现需先获取新 Token，而重复点击会导致后续请求无有效 Token。</font>

### <font style="color:rgb(36, 41, 47);">2. </font>**<font style="color:rgb(36, 41, 47);">提现请求校验 Token</font>**
+ **<font style="color:rgb(36, 41, 47);">实现逻辑</font>**<font style="color:rgb(36, 41, 47);">：提现接口需校验请求中的 Token 是否存在且有效。若 Token 不存在或已失效，直接返回“重复请求”错误。</font>
+ **<font style="color:rgb(36, 41, 47);">示例流程</font>**<font style="color:rgb(36, 41, 47);">：</font>

```java
// 伪代码：校验 Token
String token = request.getParameter("token");
if (!redis.exists(token)) {
    return "重复请求，请重新发起提现";
}
redis.del(token); // 删除 Token，确保仅一次使用
```

### <font style="color:rgb(36, 41, 47);">3.</font><font style="color:rgb(36, 41, 47);"> </font>**<font style="color:rgb(36, 41, 47);">数据库唯一索引防重</font>**
+ **<font style="color:rgb(36, 41, 47);">实现逻辑</font>**<font style="color:rgb(36, 41, 47);">：创建提现流水表，以订单号（</font>`<font style="color:rgb(36, 41, 47);">order_id</font>`<font style="color:rgb(36, 41, 47);">）或 Token 作为唯一索引。处理提现时，先插入流水记录，利用数据库的唯一约束阻止重复操作。</font>
+ **<font style="color:rgb(36, 41, 47);">表结构示例</font>**<font style="color:rgb(36, 41, 47);">：</font>

```plsql
CREATE TABLE withdraw_record (
  order_id VARCHAR(64) PRIMARY KEY,
  user_id BIGINT,
  amount DECIMAL(10,2),
  status TINYINT
);
```

+ **<font style="color:rgb(36, 41, 47);">操作步骤</font>**<font style="color:rgb(36, 41, 47);">：</font>
    1. <font style="color:rgb(36, 41, 47);">插入流水记录：</font>`<font style="color:rgb(36, 41, 47);">INSERT INTO withdraw_record (order_id, user_id, amount, status) VALUES ('order_123', 1001, 100.00, 1)</font>`<font style="color:rgb(36, 41, 47);">。</font>
    2. <font style="color:rgb(36, 41, 47);">若插入失败（唯一索引冲突），直接返回“提现已处理”。</font>

### <font style="color:rgb(36, 41, 47);">4.</font><font style="color:rgb(36, 41, 47);"> </font>**<font style="color:rgb(36, 41, 47);">乐观锁控制余额更新</font>**
+ **<font style="color:rgb(36, 41, 47);">实现逻辑</font>**<font style="color:rgb(36, 41, 47);">：更新用户余额时，增加版本号字段（</font>`<font style="color:rgb(36, 41, 47);">version</font>`<font style="color:rgb(36, 41, 47);">），仅当版本号匹配时才执行扣款，防止并发覆盖</font><font style="color:rgb(36, 41, 47);">。</font>
+ **<font style="color:rgb(36, 41, 47);">SQL 示例</font>**<font style="color:rgb(36, 41, 47);">：</font>

```plsql
UPDATE account 
SET balance = balance - 100, version = version + 1 
WHERE user_id = 1001 AND balance >= 100 AND version = 1;
```

+ **<font style="color:rgb(36, 41, 47);">校验结果</font>**<font style="color:rgb(36, 41, 47);">：若影响行数为0，说明余额不足或版本号不匹配，返回“提现失败”。</font>

### <font style="color:rgb(36, 41, 47);">5.</font><font style="color:rgb(36, 41, 47);"> </font>**<font style="color:rgb(36, 41, 47);">分布式锁防止并发</font>**
+ **<font style="color:rgb(36, 41, 47);">实现逻辑</font>**<font style="color:rgb(36, 41, 47);">：在扣款前，使用 Redis 分布式锁（如</font>`<font style="color:rgb(36, 41, 47);">SETNX</font>`<font style="color:rgb(36, 41, 47);">命令）锁定用户 ID 或订单号，确保同一时间仅一个请求处理提现。</font>
+ **<font style="color:rgb(36, 41, 47);">伪代码示例</font>**<font style="color:rgb(36, 41, 47);">：</font>

```java
String lockKey = "withdraw_lock:" + userId;
boolean locked = redis.setnx(lockKey, "1", 10); // 锁超时10秒
if (!locked) {
    return "系统繁忙，请稍后重试";
}
try {
    // 执行扣款和流水插入操作
} finally {
    redis.del(lockKey); // 释放锁
}
```

### <font style="color:rgb(36, 41, 47);">6.</font><font style="color:rgb(36, 41, 47);"> </font>**<font style="color:rgb(36, 41, 47);">事务与回滚机制</font>**
+ **<font style="color:rgb(36, 41, 47);">实现逻辑</font>**<font style="color:rgb(36, 41, 47);">：将插入流水记录和更新余额操作放在同一数据库事务中，确保原子性。若任一操作失败，事务回滚</font><font style="color:rgb(36, 41, 47);">。</font>
+ **<font style="color:rgb(36, 41, 47);">示例</font>**<font style="color:rgb(36, 41, 47);">：</font>

```plsql
BEGIN TRANSACTION;
  INSERT INTO withdraw_record ...;
  UPDATE account ...;
COMMIT;
```

### <font style="color:rgb(36, 41, 47);">7.</font><font style="color:rgb(36, 41, 47);"> </font>**<font style="color:rgb(36, 41, 47);">结果缓存与快速响应</font>**
+ **<font style="color:rgb(36, 41, 47);">实现逻辑</font>**<font style="color:rgb(36, 41, 47);">：提现成功后，将结果（如订单状态）缓存到 Redis。后续相同请求直接返回缓存结果，避免重复处理。</font>
+ **<font style="color:rgb(36, 41, 47);">示例</font>**<font style="color:rgb(36, 41, 47);">：</font>

```java
String resultKey = "withdraw_result:" + orderId;
redis.setex(resultKey, 3600, "success"); // 缓存1小时
```

### <font style="color:rgb(36, 41, 47);">最终流程整合</font><font style="color:#DF2A3F;">（实质上以下流程并不是所有节点都需要，按实际需求进行选择，下面的处理过程是悲观中的悲观解决方案）</font>
1. <font style="color:rgb(36, 41, 47);">用户点击提现按钮，前端向后端申请Token。</font>
2. <font style="color:rgb(36, 41, 47);">后端生成 Token 并存入 Redis，返回给前端。</font>
3. <font style="color:rgb(36, 41, 47);">用户提交提现请求，携带 Token、金额和用户信息。</font>
4. <font style="color:rgb(36, 41, 47);">后端校验 Token 有效性，无效则直接拒绝。</font>
5. <font style="color:rgb(36, 41, 47);">获取分布式锁，防止并发请求。</font>
6. <font style="color:rgb(36, 41, 47);">插入提现流水记录，利用唯一索引拦截重复请求。</font>
7. <font style="color:rgb(36, 41, 47);">使用乐观锁更新用户余额，确保扣款安全。</font>
8. <font style="color:rgb(36, 41, 47);">事务提交后释放分布式锁，并缓存提现结果。</font>
9. <font style="color:rgb(36, 41, 47);">后续重复请求因 Token 失效、流水记录冲突或缓存命中，直接返回首次结果。</font>

### <font style="color:rgb(36, 41, 47);">注意事项</font>
+ **<font style="color:rgb(36, 41, 47);">Token 有效期</font>**<font style="color:rgb(36, 41, 47);">：需根据前端交互合理设置，过长可能导致安全性问题，过短可能影响用户体验。</font>
+ **<font style="color:rgb(36, 41, 47);">锁超时时间</font>**<font style="color:rgb(36, 41, 47);">：需大于事务处理时间，避免锁提前释放导致并发问题。</font>
+ **<font style="color:rgb(36, 41, 47);">对账机制</font>**<font style="color:rgb(36, 41, 47);">：极端情况下（如扣款成功但响应超时），需有定时任务核对流水与账户余额，修复不一致</font><font style="color:rgb(36, 41, 47);">。</font>

<font style="color:rgb(36, 41, 47);">通过上述方案，即使多次点击提现按钮，也能保证仅扣款一次，实现接口的幂等性。</font>



> 更新: 2025-05-28 13:25:38  
> 原文: <https://www.yuque.com/tulingzhouyu/db22bv/egyagslix1ni6rhk>